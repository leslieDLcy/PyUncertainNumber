PyUncertainNumber.pba
=====================

.. py:module:: PyUncertainNumber.pba


Submodules
----------

.. toctree::
   :maxdepth: 1

   /autoapi/PyUncertainNumber/pba/cbox/index
   /autoapi/PyUncertainNumber/pba/copula/index
   /autoapi/PyUncertainNumber/pba/core/index
   /autoapi/PyUncertainNumber/pba/dists/index
   /autoapi/PyUncertainNumber/pba/interval/index
   /autoapi/PyUncertainNumber/pba/logical/index
   /autoapi/PyUncertainNumber/pba/params/index
   /autoapi/PyUncertainNumber/pba/pbox/index
   /autoapi/PyUncertainNumber/pba/pbox_base/index
   /autoapi/PyUncertainNumber/pba/pbox_np/index
   /autoapi/PyUncertainNumber/pba/pbox_parametric/index
   /autoapi/PyUncertainNumber/pba/utils/index


Attributes
----------

.. autoapisummary::

   PyUncertainNumber.pba.I
   PyUncertainNumber.pba.I
   PyUncertainNumber.pba.dists
   PyUncertainNumber.pba.named_pbox
   PyUncertainNumber.pba.normal
   PyUncertainNumber.pba.N
   PyUncertainNumber.pba.unif
   PyUncertainNumber.pba.U
   PyUncertainNumber.pba.lognorm
   PyUncertainNumber.pba.min_max


Exceptions
----------

.. autoapisummary::

   PyUncertainNumber.pba.NotIncreasingError


Classes
-------

.. autoapisummary::

   PyUncertainNumber.pba.Interval
   PyUncertainNumber.pba.Pbox
   PyUncertainNumber.pba.Copula
   PyUncertainNumber.pba.Pbox
   PyUncertainNumber.pba.Interval
   PyUncertainNumber.pba.Cbox
   PyUncertainNumber.pba.Pbox
   PyUncertainNumber.pba.Interval
   PyUncertainNumber.pba.Logical
   PyUncertainNumber.pba.Params
   PyUncertainNumber.pba.Interval
   PyUncertainNumber.pba.Pbox


Functions
---------

.. autoapisummary::

   PyUncertainNumber.pba.PM
   PyUncertainNumber.pba.mixture
   PyUncertainNumber.pba.truncate
   PyUncertainNumber.pba.imposition
   PyUncertainNumber.pba.ClaGen
   PyUncertainNumber.pba.ClaInv
   PyUncertainNumber.pba.FGen
   PyUncertainNumber.pba.FInv
   PyUncertainNumber.pba.indep
   PyUncertainNumber.pba.perf
   PyUncertainNumber.pba.opp
   PyUncertainNumber.pba.Cla
   PyUncertainNumber.pba.F
   PyUncertainNumber.pba.Gau
   PyUncertainNumber.pba.pi
   PyUncertainNumber.pba.M
   PyUncertainNumber.pba.W
   PyUncertainNumber.pba.Frank
   PyUncertainNumber.pba.Clayton
   PyUncertainNumber.pba.Gaussian
   PyUncertainNumber.pba.envelope
   PyUncertainNumber.pba.env
   PyUncertainNumber.pba.sum
   PyUncertainNumber.pba.mean
   PyUncertainNumber.pba.mul
   PyUncertainNumber.pba.sqrt
   PyUncertainNumber.pba.PM
   PyUncertainNumber.pba.is_same_as
   PyUncertainNumber.pba.always
   PyUncertainNumber.pba.never
   PyUncertainNumber.pba.sometimes
   PyUncertainNumber.pba.xtimes
   PyUncertainNumber.pba.__get_bounds
   PyUncertainNumber.pba.lognormal
   PyUncertainNumber.pba.alpha
   PyUncertainNumber.pba.anglit
   PyUncertainNumber.pba.arcsine
   PyUncertainNumber.pba.argus
   PyUncertainNumber.pba.beta
   PyUncertainNumber.pba.betaprime
   PyUncertainNumber.pba.bradford
   PyUncertainNumber.pba.burr
   PyUncertainNumber.pba.burr12
   PyUncertainNumber.pba.cauchy
   PyUncertainNumber.pba.chi
   PyUncertainNumber.pba.chi2
   PyUncertainNumber.pba.cosine
   PyUncertainNumber.pba.crystalball
   PyUncertainNumber.pba.dgamma
   PyUncertainNumber.pba.dweibull
   PyUncertainNumber.pba.erlang
   PyUncertainNumber.pba.expon
   PyUncertainNumber.pba.exponnorm
   PyUncertainNumber.pba.exponweib
   PyUncertainNumber.pba.exponpow
   PyUncertainNumber.pba.f
   PyUncertainNumber.pba.fatiguelife
   PyUncertainNumber.pba.fisk
   PyUncertainNumber.pba.foldcauchy
   PyUncertainNumber.pba.foldnorm
   PyUncertainNumber.pba.genlogistic
   PyUncertainNumber.pba.gennorm
   PyUncertainNumber.pba.genpareto
   PyUncertainNumber.pba.genexpon
   PyUncertainNumber.pba.genextreme
   PyUncertainNumber.pba.gausshyper
   PyUncertainNumber.pba.gamma
   PyUncertainNumber.pba.gengamma
   PyUncertainNumber.pba.genhalflogistic
   PyUncertainNumber.pba.geninvgauss
   PyUncertainNumber.pba.gompertz
   PyUncertainNumber.pba.gumbel_r
   PyUncertainNumber.pba.gumbel_l
   PyUncertainNumber.pba.halfcauchy
   PyUncertainNumber.pba.halflogistic
   PyUncertainNumber.pba.halfnorm
   PyUncertainNumber.pba.halfgennorm
   PyUncertainNumber.pba.hypsecant
   PyUncertainNumber.pba.invgamma
   PyUncertainNumber.pba.invgauss
   PyUncertainNumber.pba.invweibull
   PyUncertainNumber.pba.johnsonsb
   PyUncertainNumber.pba.johnsonsu
   PyUncertainNumber.pba.kappa4
   PyUncertainNumber.pba.kappa3
   PyUncertainNumber.pba.ksone
   PyUncertainNumber.pba.kstwobign
   PyUncertainNumber.pba.laplace
   PyUncertainNumber.pba.levy
   PyUncertainNumber.pba.levy_l
   PyUncertainNumber.pba.levy_stable
   PyUncertainNumber.pba.logistic
   PyUncertainNumber.pba.loggamma
   PyUncertainNumber.pba.loglaplace
   PyUncertainNumber.pba.loguniform
   PyUncertainNumber.pba.lomax
   PyUncertainNumber.pba.maxwell
   PyUncertainNumber.pba.mielke
   PyUncertainNumber.pba.moyal
   PyUncertainNumber.pba.nakagami
   PyUncertainNumber.pba.ncx2
   PyUncertainNumber.pba.ncf
   PyUncertainNumber.pba.nct
   PyUncertainNumber.pba.norm
   PyUncertainNumber.pba.norminvgauss
   PyUncertainNumber.pba.pareto
   PyUncertainNumber.pba.pearson3
   PyUncertainNumber.pba.powerlaw
   PyUncertainNumber.pba.powerlognorm
   PyUncertainNumber.pba.powernorm
   PyUncertainNumber.pba.rdist
   PyUncertainNumber.pba.rayleigh
   PyUncertainNumber.pba.rice
   PyUncertainNumber.pba.recipinvgauss
   PyUncertainNumber.pba.semicircular
   PyUncertainNumber.pba.skewnorm
   PyUncertainNumber.pba.t
   PyUncertainNumber.pba.trapz
   PyUncertainNumber.pba.triang
   PyUncertainNumber.pba.truncexpon
   PyUncertainNumber.pba.truncnorm
   PyUncertainNumber.pba.tukeylambda
   PyUncertainNumber.pba.uniform
   PyUncertainNumber.pba.vonmises
   PyUncertainNumber.pba.vonmises_line
   PyUncertainNumber.pba.wald
   PyUncertainNumber.pba.weibull_min
   PyUncertainNumber.pba.weibull_max
   PyUncertainNumber.pba.weibull
   PyUncertainNumber.pba.wrapcauchy
   PyUncertainNumber.pba.bernoulli
   PyUncertainNumber.pba.betabinom
   PyUncertainNumber.pba.binom
   PyUncertainNumber.pba.boltzmann
   PyUncertainNumber.pba.dlaplace
   PyUncertainNumber.pba.geom
   PyUncertainNumber.pba.hypergeom
   PyUncertainNumber.pba.logser
   PyUncertainNumber.pba.nbinom
   PyUncertainNumber.pba.planck
   PyUncertainNumber.pba.poisson
   PyUncertainNumber.pba.randint
   PyUncertainNumber.pba.skellam
   PyUncertainNumber.pba.zipf
   PyUncertainNumber.pba.yulesimon
   PyUncertainNumber.pba.KM
   PyUncertainNumber.pba.KN
   PyUncertainNumber.pba.known_properties
   PyUncertainNumber.pba.box
   PyUncertainNumber.pba.min_max_mean
   PyUncertainNumber.pba.min_mean
   PyUncertainNumber.pba.min_max_mean_std
   PyUncertainNumber.pba.min_max_mean_var
   PyUncertainNumber.pba.min_max_mode
   PyUncertainNumber.pba.min_max_median
   PyUncertainNumber.pba.min_max_median_is_mode
   PyUncertainNumber.pba.mean_std
   PyUncertainNumber.pba.mean_var
   PyUncertainNumber.pba.pos_mean_std
   PyUncertainNumber.pba.symmetric_mean_std
   PyUncertainNumber.pba.from_percentiles


Package Contents
----------------

.. py:class:: Interval(left=None, right=None)

   An interval is an uncertain number for which only the endpoints are known, :math:`x=[a,b]`.
   This is interpreted as :math:`x` being between :math:`a` and :math:`b` but with no more information about the value of :math:`x`.

   Intervals embody epistemic uncertainty within PBA.

   Creation
   ________

   Intervals can be created using either of the following:

   .. code-block:: python

       >>> pba.Interval(0,1)
       Interval [0,1]
       >>> pba.I(2,3)
       Interval [2,3]

   .. tip::

       The shorthand ``I`` is an alias for ``Interval``

   Intervals can also be created from a single value ± half-width:

   >>> pba.PM(0,1)
   Interval [-1,1]

   By default intervals are displayed as ``Interval [a,b]`` where ``a`` and ``b`` are the left and right endpoints respectively. This can be changed using the `interval.pm_repr`_ and `interval.lr_repr`_ functions.

   Arithmetic
   __________

   For two intervals [a,b] and [c,d] the following arithmetic operations are defined:

   **Addition**

   :math:`[a,b] + [c,d] = [a+c,b+d]`

   **Subtraction**

   :math:`[a,b] - [c,d] = [a-d,b-c]`

   **Multiplication**

   :math:`[a,b] * [c,d] = [\min(ac,ad,bc,bd),\max(ac,ad,bc,bd)]`

   **Division**

   :math:`[a,b] / [c,d] = [a,b] * \frac{1}{[c,d]} \equiv [\min(a/c,a/d,b/c,b/d),\max(a/c,a/d,b/c,b/d)]`

   Alternative arithmetic methods are described in `interval.add`_, `interval.sub`_, `interval.mul`_, `interval.div`_.



   .. py:attribute:: _left


   .. py:attribute:: _right


   .. py:property:: left


   .. py:property:: right


   .. py:method:: __repr__() -> str


   .. py:method:: __str__() -> str


   .. py:method:: __format__(format_spec: str) -> str


   .. py:method:: __iter__()


   .. py:method:: __len__()


   .. py:method:: __radd__(left)


   .. py:method:: __sub__(other)


   .. py:method:: __rsub__(other)


   .. py:method:: __neg__()


   .. py:method:: __mul__(other)


   .. py:method:: __rmul__(other)


   .. py:method:: __truediv__(other)


   .. py:method:: __rtruediv__(other)


   .. py:method:: __pow__(other)


   .. py:method:: __rpow__(left)


   .. py:method:: __lt__(other)


   .. py:method:: __rgt__(other)


   .. py:method:: __eq__(other)

      ==



   .. py:method:: __gt__(other)

      >



   .. py:method:: __rlt__(other)


   .. py:method:: __ne__(other)

      !=



   .. py:method:: __le__(other)

      <=



   .. py:method:: __ge__(other)


   .. py:method:: __bool__()


   .. py:method:: __abs__()


   .. py:method:: __contains__(other)


   .. py:method:: add(other, method=None)

      .. _interval.add:

      Adds the interval and another object together.


      **Args**:

          ``other``: The interval or numeric value to be added. This value must be transformable into an Interval object.

      **Methods**:

          p - perfect arithmetic :math:`[a,b]+[c,d] = [a + c, b + d]`

          o - opposite arithmetic :math:`[a,b]+[c,d] = [a + d, b + c]`

          None, i, f - Standard interval arithmetic is used.

      **Returns**:

          ``Interval``




   .. py:method:: __add__(other)


   .. py:method:: padd(other)

      .. warning::
          This method is deprecated. Use add(other, method='p') instead.



   .. py:method:: oadd(other)

      .. warning::
          This method is deprecated. Use add(other, method='o') instead.



   .. py:method:: sub(other, method=None)

      .. _interval.sub:

      Subtracts other from self.

      **Args**:

          ``other``: The interval or numeric value to be subracted. This value must be transformable into an Interval object.

      **Methods**:

          ``p``: perfect arithmetic :math:`a+b = [a.left - b.left, a.right - b.right]`

          ``o``: opposite arithmetic :math:`a+b = [a.left - b.right, a.right - b.left]`

          None, i, f - Standard interval arithmetic is used.

      **Returns**:

          ``Interval``




   .. py:method:: psub(other)

      .. warning::
          Depreciated use self.sub(other, method = 'p') instead



   .. py:method:: osub(other)

      .. warning::
          Depreciated use self.sub(other, method = 'o') instead



   .. py:method:: mul(other, method=None)

      .. _interval.mul:

      Multiplies self by other.

      **Args**:

          ``other``: The interval or numeric value to be multiplied. This value must be transformable into an Interval object.


      **Methods**:
          ``p``: perfect arithmetic :math:`[a,b],[c,d] = [a * c, b * d]`

          ``o``: opposite arithmetic :math:`[a,b],[c,d] = [a * d, b * c]`

          None, i, f - Standard interval arithmetic is used.

      **Returns**:
          Interval: The result of the multiplication.





   .. py:method:: pmul(other)

      .. warning::
          Depreciated use self.mul(other, method = 'p') instead



   .. py:method:: omul(other)

      .. warning::
          Depreciated use self.mul(other, method = 'o') instead



   .. py:method:: div(other, method=None)

      .. _interval.div:

      Divides self by other


      If :math:`0 \in other` it returns a division by zero error


      **Args**:

          ``other`` (Interval or numeric): The interval or numeric value to be multiplied. This value must be transformable into an Interval object.

      **Methods**:

          ``p``: perfect arithmetic :math:`[a,b],[c,d] = [a * 1/c, b * 1/d]`

          ``o``: opposite arithmetic :math:`[a,b],[c,d] = [a * 1/d, b * 1/c]`

          ``None``, ``i``, ``f`` - Standard interval arithmetic is used.

      .. admonition:: Implementation

          >>> self.add(1/other, method = method)

      .. error::

          If :math:`0 \in [a,b]` it returns a division by zero error




   .. py:method:: pdiv(other)

      .. warning::
          Depreciated use self.div(other, method = 'p') instead



   .. py:method:: odiv(other)

      .. warning::
          Depreciated use self.div(other, method = 'o') instead




   .. py:method:: recip()

      Calculates the reciprocle of the interval.

      **Returns**:

          ``Interval``: Equal to :math:`[1/b,1/a]`

      **Example**:

          >>> pba.Interval(2,4).recip()
          Interval [0.25, 0.5]

      .. error::
          If :math:`0 \in [a,b]` it returns a division by zero error




   .. py:method:: equiv(other: Interval) -> bool

      Checks whether two intervals are equivalent.

      **Parameters**:

          ``other``: The interval to check against.

      **Returns** ``True`` **if**:

          ``self.left == other.right`` and ``self.right == other.right``

          ``False`` otherwise.

      .. error::

          ``TypeError``: If ``other`` is not an instance of ``Interval``

      .. seealso::
          :func:`~logical.is_same_as`

      **Examples**:

          >>> a = Interval(0,1)
          >>> b = Interval(0.5,1.5)
          >>> c = I(0,1)
          >>> a.equiv(b)
          False
          >>> a.equiv(c)
          True




   .. py:method:: lo()

      **Returns**:
          ``self.left``

      .. tip::

          This function is redundant but exists to match Pbox class for possible internal reasons.




   .. py:method:: hi()

      **Returns**:
          ``self.right``

      .. tip::

          This function is redundant but exists to match Pbox class for possible internal reasons.




   .. py:method:: width() -> float

      **Returns**:

          ``float``: The width of the interval, :math:`\mathrm{right} - \mathrm{left}`

      **Example**:

          >>> pba.Interval(0,3).width()
          3




   .. py:method:: halfwidth() -> float

      **Returns**:

          ``float``: The half-width of the interval, :math:`(\mathrm{right} - \mathrm{left})/2`

      **Example**:

          >>> pba.Interval(0,3).halfwidth()
          1.5

      .. admonition:: Implementation

          >>> self.width()/2




   .. py:method:: midpoint() -> float

      Returns the midpoint of the interval

      .. note:: - this serves as the deterministic value representation of the interval, a.k.a. the naked value for an interval

      :returns: The midpoint of the interval, :math:`(\mathrm{right} + \mathrm{left})/2`
      :rtype: ``float``

      **Example**:
              >>> pba.Interval(0,2).midpoint()
              1.0



   .. py:method:: to_logical()

      Turns the interval into a logical interval, this is done by chacking the truth value of the ends of the interval

      **Returns**:

          ``Logical``: The logical interval

      .. admonition:: Implementation

          >>> left = self.left.__bool__()
          >>> right = self.right.__bool__()
          >>> Logical(left,right)





   .. py:method:: env(other: Union[list, Interval]) -> Interval

      Calculates the envelope between two intervals

      **Parameters**:

          ``other`` : Interval or list. The interval to envelope with self

      .. hint::

          If other is a list then the envelope is calculated between self and each element of the list. In this case the envelope is calculated recursively and pba.envelope() may be more efficient.

      .. important::
          If other is a Pbox then ``Pbox.env()`` is called

      .. seealso::

          `pba.core.envelope`_

          `pba.pbox.Pbox.env`_

      **Returns**:

          ``Interval``: The envelope of self and other





   .. py:method:: straddles(N: Union[int, float, Interval], endpoints: bool = True) -> bool

      .. _interval.straddles:

      **Parameters**:

          ``N``: Number to check. If N is an interval checks whether the whole interval is within self.

          ``endpoints``: Whether to include the endpoints within the check

      **Returns** ``True`` **if**:

          :math:`\mathrm{left} \leq N \leq \mathrm{right}` (Assuming ``endpoints=True``).

          For interval values. :math:`\mathrm{left} \leq N.left \leq \mathrm{right}` and :math:`\mathrm{left} \leq N.right \leq \mathrm{right}` (Assuming ``endpoints=True``).

          ``False`` otherwise.

      .. tip::

          ``N in self`` is equivalent to ``self.straddles(N)``




   .. py:method:: straddles_zero(endpoints=True)

      Checks whether :math:`0` is within the interval

      .. admonition:: Implementation

          Equivalent to ``self.straddles(0,endpoints)``

      .. seealso::
          interval.straddles_




   .. py:method:: intersection(other: Union[Interval, list]) -> Interval

      Calculates the intersection between intervals

      **Parameters**:

          ``other``: The interval to intersect with self. If an interval is not given will try to cast as an interval. If a list is given will calculate the intersection between self and each element of the list.

      **Returns**:

          ``Interval``: The intersection of self and other. If no intersection is found returns ``None``

      **Example**:

          >>> a = Interval(0,1)
          >>> b = Interval(0.5,1.5)
          >>> a.intersection(b)
          Interval [0.5, 1]



   .. py:method:: exp()


   .. py:method:: log()


   .. py:method:: sqrt()


   .. py:method:: display(title='', ax=None, style='simple', **kwargs)


   .. py:method:: sample(seed=None, numpy_rng: numpy.random.Generator = None) -> float

      Generate a random sample within the interval.

      **Parameters**:

          ``seed`` (int, optional): Seed value for random number generation. Defaults to None.

          ``numpy_rng`` (numpy.random.Generator, optional): Numpy random number generator. Defaults to None.

      **Returns**:

          ``float``: Random sample within the interval.

      .. admonition:: Implementation

          If ``numpy_rng`` is given:

              >>> numpy_rng.uniform(self.left, self.right)

          Otherwise the following is used:

          >>> import random
          >>> random.seed(seed)
          >>> self.left + random.random() * self.width()

      **Examples**:

          >>> pba.Interval(0,1).sample()
          0.6160988752201705
          >>> pba.I(0,1).sample(seed = 1)
          0.13436424411240122

      If a numpy random number generator is given then it is used instead of the default python random number generator. It has to be initialised first.

          >>> import numpy as np
          >>> rng = np.random.default_rng(seed = 0)
          >>> pba.I(0,1).sample(numpy_rng = rng)
          0.6369616873214543



   .. py:method:: from_midwith(midpoint: float, halfwidth: float) -> Interval
      :classmethod:


      Creates an Interval object from a midpoint and half-width.

      :param - midpoint: The midpoint of the interval.
      :type - midpoint: float
      :param - halfwidth: The half-width of the interval.
      :type - halfwidth: float

      :returns: The interval with midpoint and half-width.
      :rtype: - Interval

      .. rubric:: Example

      >>> pba.Interval.from_midwith(0,1)
      Interval [-1, 1]



.. py:data:: I

.. py:function:: PM(x, hw)

   Create an interval centered around x with a half-width of hw.

   # TODO: a constructor for creating an interval from a midpoint and half-width
   # ! this func is weird and I keep it only for not breaking the code in other places.

   **Parameters**:

       ``x`` (float): The center value of the interval.

       ``hw`` (float): The half-width of the interval.

   **Returns**:

       ``Interval``: An interval object with lower bound x-hw and upper bound x+hw.

   .. error::

       ``ValueError``: If hw is less than 0.

   .. rubric:: Example

   >>> pba.PM(0, 1)
   Interval [-1, 1]


.. py:class:: Pbox(left=None, right=None, steps=None, shape=None, mean_left=None, mean_right=None, var_left=None, var_right=None, interpolation='linear')

   not the main constructor BUT the base constructor


   .. py:attribute:: STEPS

      Leslie:
      - Essentially, from the code implementation, a Pbox object is defined by the left and right bounds (i.e. nd.arrays).
      - Advantage is that this unifies both parametric and non-parametric pboxes but disadvantage is it discards the parameter
      information of the bounds which we may desire in the case of Cbox.


   .. py:attribute:: left


   .. py:attribute:: right


   .. py:attribute:: steps


   .. py:attribute:: shape


   .. py:attribute:: mean_left


   .. py:attribute:: mean_right


   .. py:attribute:: var_left
      :value: 0



   .. py:attribute:: var_right


   .. py:method:: get_range()

      get the range for either a pbox or a distribution

      .. note:: - #! added by Leslie



   .. py:property:: rangel

      leslie defined range property


   .. py:method:: __repr__()


   .. py:attribute:: __str__


   .. py:method:: __iter__()


   .. py:method:: __neg__()


   .. py:method:: __lt__(other)


   .. py:method:: __rlt__(other)


   .. py:method:: __le__(other)


   .. py:method:: __rle__(other)


   .. py:method:: __gt__(other)


   .. py:method:: __rgt__(other)


   .. py:method:: __ge__(other)


   .. py:method:: __rge__(other)


   .. py:method:: __and__(other)


   .. py:method:: __rand__(other)


   .. py:method:: __or__(other)


   .. py:method:: __ror__(other)


   .. py:method:: __add__(other)


   .. py:method:: __radd__(other)


   .. py:method:: __sub__(other)


   .. py:method:: __rsub__(other)


   .. py:method:: __mul__(other)


   .. py:method:: __rmul__(other)


   .. py:method:: __pow__(other)


   .. py:method:: __rpow__(other)


   .. py:method:: __truediv__(other)


   .. py:method:: __rtruediv__(other)


   .. py:method:: lo()

      Returns the left-most value in the interval



   .. py:method:: hi()

      Returns the right-most value in the interval



   .. py:method:: _computemoments()


   .. py:method:: _checkmoments()


   .. py:method:: cut()


   .. py:method:: cuth(x)

      get the bounds on the cumulative probability associated with any x-value



   .. py:method:: cutv(p=0.5)

      get the bounds on the x-value at any particular probability level



   .. py:method:: _unary(*args, function=lambda x: x)


   .. py:method:: add(other: Union[Pbox, PyUncertainNumber.pba.interval.Interval, float, int], method='f') -> Pbox

      Adds to Pbox to other using the defined dependency method





   .. py:method:: pow(other: Union[Pbox, PyUncertainNumber.pba.interval.Interval, float, int], method='f') -> Pbox

      Raises a p-box to the power of other using the defined dependency method

      :param other: Pbox, Interval or numeric type
      :param method:

      :return: Pbox
      :rtype: Pbox




   .. py:method:: sub(other, method='f')


   .. py:method:: mul(other, method='f')


   .. py:method:: div(other, method='f')


   .. py:method:: exp()


   .. py:method:: sqrt()


   .. py:method:: recip()


   .. py:method:: lt(other, method='f')


   .. py:method:: le(other, method='f')


   .. py:method:: gt(other, method='f')


   .. py:method:: ge(other, method='f')


   .. py:method:: min(other, method='f')

      Returns a new Pbox object that represents the element-wise minimum of two Pboxes.

      :param - other: Another Pbox object or a numeric value.
      :param - method: Calculation method to determine the minimum. Can be one of 'f', 'p', 'o', 'i'.

      :returns: Pbox



   .. py:method:: max(other, method='f')


   .. py:method:: truncate(a, b, method='f')

      Equivalent to self.min(a,method).max(b,method)



   .. py:method:: env(other)

      .. _interval.env:

      Computes the envelope of two Pboxes.

      Parameters:
      - other: Pbox or numeric value
          The other Pbox or numeric value to compute the envelope with.

      Returns:
      - Pbox
          The envelope Pbox.

      Raises:
      - ArithmeticError: If both Pboxes have different number of steps.



   .. py:method:: logicaland(other, method='f')


   .. py:method:: logicalor(other, method='f')


   .. py:method:: get_interval(*args) -> PyUncertainNumber.pba.interval.Interval


   .. py:method:: get_probability(val) -> PyUncertainNumber.pba.interval.Interval


   .. py:method:: summary() -> str


   .. py:method:: mean() -> PyUncertainNumber.pba.interval.Interval

      Returns the mean of the pbox



   .. py:method:: median() -> PyUncertainNumber.pba.interval.Interval

      Returns the median of the distribution



   .. py:method:: support() -> PyUncertainNumber.pba.interval.Interval


   .. py:method:: get_x()

      returns the x values for plotting



   .. py:method:: get_y()

      returns the y values for plotting



   .. py:method:: straddles(N, endpoints=True) -> bool

      :param N: Number to check
      :type N: numeric
      :param endpoints: Whether to include the endpoints within the check
      :type endpoints: bool

      :returns: * *True* -- If :math:`\mathrm{left} \leq N \leq \mathrm{right}` (Assuming `endpoints=True`)
                * *False* -- Otherwise



   .. py:method:: straddles_zero(endpoints=True) -> bool

      Checks whether :math:`0` is within the p-box



   .. py:method:: imp(other)

      Returns the imposition of self with other



   .. py:method:: show(figax=None, now=True, title='', x_axis_label='x', **kwargs)


   .. py:attribute:: plot


   .. py:method:: display(title='', ax=None, style='simple', fill_color='lightgray', **kwargs)

      quickly plot the pba object

      # !Leslie defined plotting function



.. py:function:: mixture(*args: Union[Pbox, PyUncertainNumber.pba.interval.Interval, float, int], weights: List[Union[float, int]] = [], steps: int = Pbox.STEPS) -> Pbox

   Mixes the pboxes in *args
   :param \*args: Number of p-boxes or objects to be mixed
   :param weights: Right side of box

   :rtype: Pbox


.. py:function:: truncate(pbox, min, max)

.. py:function:: imposition(*args: Union[Pbox, PyUncertainNumber.pba.interval.Interval, float, int])

   Returns the imposition of the p-boxes in *args

   :param \*args: Number of p-boxes or objects to be mixed

   :rtype: Pbox


.. py:exception:: NotIncreasingError

   Bases: :py:obj:`Exception`


   Common base class for all non-exit exceptions.


.. py:class:: Copula(cdf=None, func=None, param=None)

   Bases: :py:obj:`object`


   .. py:attribute:: cdf


   .. py:attribute:: func


   .. py:attribute:: param


   .. py:method:: __repr__()


   .. py:method:: get_cdf(x, y)


   .. py:method:: get_mass(x, y)


   .. py:method:: show(pn=50, fontsize=20, cols=cm.RdGy)


   .. py:method:: showContour(fontsize=20, cols=cm.coolwarm)


.. py:function:: ClaGen(x, t=1)

.. py:function:: ClaInv(x, t=1)

.. py:function:: FGen(x, s=1)

.. py:function:: FInv(x, s=1)

.. py:function:: indep(x, y)

.. py:function:: perf(x, y)

.. py:function:: opp(x, y)

.. py:function:: Cla(x, y, t=1)

.. py:function:: F(x, y, s=1)

.. py:function:: Gau(x, y, r=0)

.. py:function:: pi(steps=200)

.. py:function:: M(steps=200)

.. py:function:: W(steps=200)

.. py:function:: Frank(s=0, steps=200)

.. py:function:: Clayton(t=1, steps=200)

.. py:function:: Gaussian(r=0, steps=200)

.. py:class:: Pbox(left=None, right=None, steps=None, shape=None, mean_left=None, mean_right=None, var_left=None, var_right=None, interpolation='linear')

   not the main constructor BUT the base constructor


   .. py:attribute:: STEPS

      Leslie:
      - Essentially, from the code implementation, a Pbox object is defined by the left and right bounds (i.e. nd.arrays).
      - Advantage is that this unifies both parametric and non-parametric pboxes but disadvantage is it discards the parameter
      information of the bounds which we may desire in the case of Cbox.


   .. py:attribute:: left


   .. py:attribute:: right


   .. py:attribute:: steps


   .. py:attribute:: shape


   .. py:attribute:: mean_left


   .. py:attribute:: mean_right


   .. py:attribute:: var_left
      :value: 0



   .. py:attribute:: var_right


   .. py:method:: get_range()

      get the range for either a pbox or a distribution

      .. note:: - #! added by Leslie



   .. py:property:: rangel

      leslie defined range property


   .. py:method:: __repr__()


   .. py:attribute:: __str__


   .. py:method:: __iter__()


   .. py:method:: __neg__()


   .. py:method:: __lt__(other)


   .. py:method:: __rlt__(other)


   .. py:method:: __le__(other)


   .. py:method:: __rle__(other)


   .. py:method:: __gt__(other)


   .. py:method:: __rgt__(other)


   .. py:method:: __ge__(other)


   .. py:method:: __rge__(other)


   .. py:method:: __and__(other)


   .. py:method:: __rand__(other)


   .. py:method:: __or__(other)


   .. py:method:: __ror__(other)


   .. py:method:: __add__(other)


   .. py:method:: __radd__(other)


   .. py:method:: __sub__(other)


   .. py:method:: __rsub__(other)


   .. py:method:: __mul__(other)


   .. py:method:: __rmul__(other)


   .. py:method:: __pow__(other)


   .. py:method:: __rpow__(other)


   .. py:method:: __truediv__(other)


   .. py:method:: __rtruediv__(other)


   .. py:method:: lo()

      Returns the left-most value in the interval



   .. py:method:: hi()

      Returns the right-most value in the interval



   .. py:method:: _computemoments()


   .. py:method:: _checkmoments()


   .. py:method:: cut()


   .. py:method:: cuth(x)

      get the bounds on the cumulative probability associated with any x-value



   .. py:method:: cutv(p=0.5)

      get the bounds on the x-value at any particular probability level



   .. py:method:: _unary(*args, function=lambda x: x)


   .. py:method:: add(other: Union[Pbox, PyUncertainNumber.pba.interval.Interval, float, int], method='f') -> Pbox

      Adds to Pbox to other using the defined dependency method





   .. py:method:: pow(other: Union[Pbox, PyUncertainNumber.pba.interval.Interval, float, int], method='f') -> Pbox

      Raises a p-box to the power of other using the defined dependency method

      :param other: Pbox, Interval or numeric type
      :param method:

      :return: Pbox
      :rtype: Pbox




   .. py:method:: sub(other, method='f')


   .. py:method:: mul(other, method='f')


   .. py:method:: div(other, method='f')


   .. py:method:: exp()


   .. py:method:: sqrt()


   .. py:method:: recip()


   .. py:method:: lt(other, method='f')


   .. py:method:: le(other, method='f')


   .. py:method:: gt(other, method='f')


   .. py:method:: ge(other, method='f')


   .. py:method:: min(other, method='f')

      Returns a new Pbox object that represents the element-wise minimum of two Pboxes.

      :param - other: Another Pbox object or a numeric value.
      :param - method: Calculation method to determine the minimum. Can be one of 'f', 'p', 'o', 'i'.

      :returns: Pbox



   .. py:method:: max(other, method='f')


   .. py:method:: truncate(a, b, method='f')

      Equivalent to self.min(a,method).max(b,method)



   .. py:method:: env(other)

      .. _interval.env:

      Computes the envelope of two Pboxes.

      Parameters:
      - other: Pbox or numeric value
          The other Pbox or numeric value to compute the envelope with.

      Returns:
      - Pbox
          The envelope Pbox.

      Raises:
      - ArithmeticError: If both Pboxes have different number of steps.



   .. py:method:: logicaland(other, method='f')


   .. py:method:: logicalor(other, method='f')


   .. py:method:: get_interval(*args) -> PyUncertainNumber.pba.interval.Interval


   .. py:method:: get_probability(val) -> PyUncertainNumber.pba.interval.Interval


   .. py:method:: summary() -> str


   .. py:method:: mean() -> PyUncertainNumber.pba.interval.Interval

      Returns the mean of the pbox



   .. py:method:: median() -> PyUncertainNumber.pba.interval.Interval

      Returns the median of the distribution



   .. py:method:: support() -> PyUncertainNumber.pba.interval.Interval


   .. py:method:: get_x()

      returns the x values for plotting



   .. py:method:: get_y()

      returns the y values for plotting



   .. py:method:: straddles(N, endpoints=True) -> bool

      :param N: Number to check
      :type N: numeric
      :param endpoints: Whether to include the endpoints within the check
      :type endpoints: bool

      :returns: * *True* -- If :math:`\mathrm{left} \leq N \leq \mathrm{right}` (Assuming `endpoints=True`)
                * *False* -- Otherwise



   .. py:method:: straddles_zero(endpoints=True) -> bool

      Checks whether :math:`0` is within the p-box



   .. py:method:: imp(other)

      Returns the imposition of self with other



   .. py:method:: show(figax=None, now=True, title='', x_axis_label='x', **kwargs)


   .. py:attribute:: plot


   .. py:method:: display(title='', ax=None, style='simple', fill_color='lightgray', **kwargs)

      quickly plot the pba object

      # !Leslie defined plotting function



.. py:function:: envelope(*args: PyUncertainNumber.pba.interval.Union[PyUncertainNumber.pba.interval.Interval, PyUncertainNumber.pba.cbox.cbox_Nick.Pbox, float]) -> PyUncertainNumber.pba.interval.Union[PyUncertainNumber.pba.interval.Interval, PyUncertainNumber.pba.cbox.cbox_Nick.Pbox]

   .. _core.envelope:

   Allows the envelope to be calculated for intervals and p-boxes.

   The envelope is the smallest interval/pbox that contains all values within the arguments.

   **Parameters**:
       ``*args``: The arguments for which the envelope needs to be calculated. The arguments can be intervals, p-boxes, or floats.

   **Returns**:
       ``Pbox|Interval``: The envelope of the given arguments, which can be an interval or a p-box.

   .. error::

       ``ValueError``: If less than two arguments are given.

       ``TypeError``: If none of the arguments are intervals or p-boxes.



.. py:function:: env(*args)

   .. warning::

       Deprecated function, use envelope() instead.



.. py:function:: sum(*args: PyUncertainNumber.pba.interval.Union[list, tuple], method='f')

   Allows the sum to be calculated for intervals and p-boxes

   **Parameters**:

       ``*args``: pboxes or intervals
       ``method`` (``f,i,o,p``): addition method to be used

   **Returns**:

       ``Interval | Pbox``: sum of interval or pbox objects within ``*args``

   .. note::

       If a list or tuple is given as the first argument, the elements of the list or tuple are used as arguments.
       If only one (non-list) argument is given, the argument is returned.




.. py:function:: mean(*args: PyUncertainNumber.pba.interval.Union[list, tuple], method='f')

   Allows the mean to be calculated for intervals and p-boxes

   **Parameters**:

       l : list of pboxes or intervals

       method : pbox addition method to be used

   **Output**:

        ``Interval | Pbox``: mean of interval or pbox objects within ``*args``

   .. important::

       Implemented as

       >>> pba.sum(*args,method = method)/len(args)



.. py:function:: mul(*args, method=None)

.. py:function:: sqrt(a)

.. py:class:: Interval(left=None, right=None)

   An interval is an uncertain number for which only the endpoints are known, :math:`x=[a,b]`.
   This is interpreted as :math:`x` being between :math:`a` and :math:`b` but with no more information about the value of :math:`x`.

   Intervals embody epistemic uncertainty within PBA.

   Creation
   ________

   Intervals can be created using either of the following:

   .. code-block:: python

       >>> pba.Interval(0,1)
       Interval [0,1]
       >>> pba.I(2,3)
       Interval [2,3]

   .. tip::

       The shorthand ``I`` is an alias for ``Interval``

   Intervals can also be created from a single value ± half-width:

   >>> pba.PM(0,1)
   Interval [-1,1]

   By default intervals are displayed as ``Interval [a,b]`` where ``a`` and ``b`` are the left and right endpoints respectively. This can be changed using the `interval.pm_repr`_ and `interval.lr_repr`_ functions.

   Arithmetic
   __________

   For two intervals [a,b] and [c,d] the following arithmetic operations are defined:

   **Addition**

   :math:`[a,b] + [c,d] = [a+c,b+d]`

   **Subtraction**

   :math:`[a,b] - [c,d] = [a-d,b-c]`

   **Multiplication**

   :math:`[a,b] * [c,d] = [\min(ac,ad,bc,bd),\max(ac,ad,bc,bd)]`

   **Division**

   :math:`[a,b] / [c,d] = [a,b] * \frac{1}{[c,d]} \equiv [\min(a/c,a/d,b/c,b/d),\max(a/c,a/d,b/c,b/d)]`

   Alternative arithmetic methods are described in `interval.add`_, `interval.sub`_, `interval.mul`_, `interval.div`_.



   .. py:attribute:: _left


   .. py:attribute:: _right


   .. py:property:: left


   .. py:property:: right


   .. py:method:: __repr__() -> str


   .. py:method:: __str__() -> str


   .. py:method:: __format__(format_spec: str) -> str


   .. py:method:: __iter__()


   .. py:method:: __len__()


   .. py:method:: __radd__(left)


   .. py:method:: __sub__(other)


   .. py:method:: __rsub__(other)


   .. py:method:: __neg__()


   .. py:method:: __mul__(other)


   .. py:method:: __rmul__(other)


   .. py:method:: __truediv__(other)


   .. py:method:: __rtruediv__(other)


   .. py:method:: __pow__(other)


   .. py:method:: __rpow__(left)


   .. py:method:: __lt__(other)


   .. py:method:: __rgt__(other)


   .. py:method:: __eq__(other)

      ==



   .. py:method:: __gt__(other)

      >



   .. py:method:: __rlt__(other)


   .. py:method:: __ne__(other)

      !=



   .. py:method:: __le__(other)

      <=



   .. py:method:: __ge__(other)


   .. py:method:: __bool__()


   .. py:method:: __abs__()


   .. py:method:: __contains__(other)


   .. py:method:: add(other, method=None)

      .. _interval.add:

      Adds the interval and another object together.


      **Args**:

          ``other``: The interval or numeric value to be added. This value must be transformable into an Interval object.

      **Methods**:

          p - perfect arithmetic :math:`[a,b]+[c,d] = [a + c, b + d]`

          o - opposite arithmetic :math:`[a,b]+[c,d] = [a + d, b + c]`

          None, i, f - Standard interval arithmetic is used.

      **Returns**:

          ``Interval``




   .. py:method:: __add__(other)


   .. py:method:: padd(other)

      .. warning::
          This method is deprecated. Use add(other, method='p') instead.



   .. py:method:: oadd(other)

      .. warning::
          This method is deprecated. Use add(other, method='o') instead.



   .. py:method:: sub(other, method=None)

      .. _interval.sub:

      Subtracts other from self.

      **Args**:

          ``other``: The interval or numeric value to be subracted. This value must be transformable into an Interval object.

      **Methods**:

          ``p``: perfect arithmetic :math:`a+b = [a.left - b.left, a.right - b.right]`

          ``o``: opposite arithmetic :math:`a+b = [a.left - b.right, a.right - b.left]`

          None, i, f - Standard interval arithmetic is used.

      **Returns**:

          ``Interval``




   .. py:method:: psub(other)

      .. warning::
          Depreciated use self.sub(other, method = 'p') instead



   .. py:method:: osub(other)

      .. warning::
          Depreciated use self.sub(other, method = 'o') instead



   .. py:method:: mul(other, method=None)

      .. _interval.mul:

      Multiplies self by other.

      **Args**:

          ``other``: The interval or numeric value to be multiplied. This value must be transformable into an Interval object.


      **Methods**:
          ``p``: perfect arithmetic :math:`[a,b],[c,d] = [a * c, b * d]`

          ``o``: opposite arithmetic :math:`[a,b],[c,d] = [a * d, b * c]`

          None, i, f - Standard interval arithmetic is used.

      **Returns**:
          Interval: The result of the multiplication.





   .. py:method:: pmul(other)

      .. warning::
          Depreciated use self.mul(other, method = 'p') instead



   .. py:method:: omul(other)

      .. warning::
          Depreciated use self.mul(other, method = 'o') instead



   .. py:method:: div(other, method=None)

      .. _interval.div:

      Divides self by other


      If :math:`0 \in other` it returns a division by zero error


      **Args**:

          ``other`` (Interval or numeric): The interval or numeric value to be multiplied. This value must be transformable into an Interval object.

      **Methods**:

          ``p``: perfect arithmetic :math:`[a,b],[c,d] = [a * 1/c, b * 1/d]`

          ``o``: opposite arithmetic :math:`[a,b],[c,d] = [a * 1/d, b * 1/c]`

          ``None``, ``i``, ``f`` - Standard interval arithmetic is used.

      .. admonition:: Implementation

          >>> self.add(1/other, method = method)

      .. error::

          If :math:`0 \in [a,b]` it returns a division by zero error




   .. py:method:: pdiv(other)

      .. warning::
          Depreciated use self.div(other, method = 'p') instead



   .. py:method:: odiv(other)

      .. warning::
          Depreciated use self.div(other, method = 'o') instead




   .. py:method:: recip()

      Calculates the reciprocle of the interval.

      **Returns**:

          ``Interval``: Equal to :math:`[1/b,1/a]`

      **Example**:

          >>> pba.Interval(2,4).recip()
          Interval [0.25, 0.5]

      .. error::
          If :math:`0 \in [a,b]` it returns a division by zero error




   .. py:method:: equiv(other: Interval) -> bool

      Checks whether two intervals are equivalent.

      **Parameters**:

          ``other``: The interval to check against.

      **Returns** ``True`` **if**:

          ``self.left == other.right`` and ``self.right == other.right``

          ``False`` otherwise.

      .. error::

          ``TypeError``: If ``other`` is not an instance of ``Interval``

      .. seealso::
          :func:`~logical.is_same_as`

      **Examples**:

          >>> a = Interval(0,1)
          >>> b = Interval(0.5,1.5)
          >>> c = I(0,1)
          >>> a.equiv(b)
          False
          >>> a.equiv(c)
          True




   .. py:method:: lo()

      **Returns**:
          ``self.left``

      .. tip::

          This function is redundant but exists to match Pbox class for possible internal reasons.




   .. py:method:: hi()

      **Returns**:
          ``self.right``

      .. tip::

          This function is redundant but exists to match Pbox class for possible internal reasons.




   .. py:method:: width() -> float

      **Returns**:

          ``float``: The width of the interval, :math:`\mathrm{right} - \mathrm{left}`

      **Example**:

          >>> pba.Interval(0,3).width()
          3




   .. py:method:: halfwidth() -> float

      **Returns**:

          ``float``: The half-width of the interval, :math:`(\mathrm{right} - \mathrm{left})/2`

      **Example**:

          >>> pba.Interval(0,3).halfwidth()
          1.5

      .. admonition:: Implementation

          >>> self.width()/2




   .. py:method:: midpoint() -> float

      Returns the midpoint of the interval

      .. note:: - this serves as the deterministic value representation of the interval, a.k.a. the naked value for an interval

      :returns: The midpoint of the interval, :math:`(\mathrm{right} + \mathrm{left})/2`
      :rtype: ``float``

      **Example**:
              >>> pba.Interval(0,2).midpoint()
              1.0



   .. py:method:: to_logical()

      Turns the interval into a logical interval, this is done by chacking the truth value of the ends of the interval

      **Returns**:

          ``Logical``: The logical interval

      .. admonition:: Implementation

          >>> left = self.left.__bool__()
          >>> right = self.right.__bool__()
          >>> Logical(left,right)





   .. py:method:: env(other: Union[list, Interval]) -> Interval

      Calculates the envelope between two intervals

      **Parameters**:

          ``other`` : Interval or list. The interval to envelope with self

      .. hint::

          If other is a list then the envelope is calculated between self and each element of the list. In this case the envelope is calculated recursively and pba.envelope() may be more efficient.

      .. important::
          If other is a Pbox then ``Pbox.env()`` is called

      .. seealso::

          `pba.core.envelope`_

          `pba.pbox.Pbox.env`_

      **Returns**:

          ``Interval``: The envelope of self and other





   .. py:method:: straddles(N: Union[int, float, Interval], endpoints: bool = True) -> bool

      .. _interval.straddles:

      **Parameters**:

          ``N``: Number to check. If N is an interval checks whether the whole interval is within self.

          ``endpoints``: Whether to include the endpoints within the check

      **Returns** ``True`` **if**:

          :math:`\mathrm{left} \leq N \leq \mathrm{right}` (Assuming ``endpoints=True``).

          For interval values. :math:`\mathrm{left} \leq N.left \leq \mathrm{right}` and :math:`\mathrm{left} \leq N.right \leq \mathrm{right}` (Assuming ``endpoints=True``).

          ``False`` otherwise.

      .. tip::

          ``N in self`` is equivalent to ``self.straddles(N)``




   .. py:method:: straddles_zero(endpoints=True)

      Checks whether :math:`0` is within the interval

      .. admonition:: Implementation

          Equivalent to ``self.straddles(0,endpoints)``

      .. seealso::
          interval.straddles_




   .. py:method:: intersection(other: Union[Interval, list]) -> Interval

      Calculates the intersection between intervals

      **Parameters**:

          ``other``: The interval to intersect with self. If an interval is not given will try to cast as an interval. If a list is given will calculate the intersection between self and each element of the list.

      **Returns**:

          ``Interval``: The intersection of self and other. If no intersection is found returns ``None``

      **Example**:

          >>> a = Interval(0,1)
          >>> b = Interval(0.5,1.5)
          >>> a.intersection(b)
          Interval [0.5, 1]



   .. py:method:: exp()


   .. py:method:: log()


   .. py:method:: sqrt()


   .. py:method:: display(title='', ax=None, style='simple', **kwargs)


   .. py:method:: sample(seed=None, numpy_rng: numpy.random.Generator = None) -> float

      Generate a random sample within the interval.

      **Parameters**:

          ``seed`` (int, optional): Seed value for random number generation. Defaults to None.

          ``numpy_rng`` (numpy.random.Generator, optional): Numpy random number generator. Defaults to None.

      **Returns**:

          ``float``: Random sample within the interval.

      .. admonition:: Implementation

          If ``numpy_rng`` is given:

              >>> numpy_rng.uniform(self.left, self.right)

          Otherwise the following is used:

          >>> import random
          >>> random.seed(seed)
          >>> self.left + random.random() * self.width()

      **Examples**:

          >>> pba.Interval(0,1).sample()
          0.6160988752201705
          >>> pba.I(0,1).sample(seed = 1)
          0.13436424411240122

      If a numpy random number generator is given then it is used instead of the default python random number generator. It has to be initialised first.

          >>> import numpy as np
          >>> rng = np.random.default_rng(seed = 0)
          >>> pba.I(0,1).sample(numpy_rng = rng)
          0.6369616873214543



   .. py:method:: from_midwith(midpoint: float, halfwidth: float) -> Interval
      :classmethod:


      Creates an Interval object from a midpoint and half-width.

      :param - midpoint: The midpoint of the interval.
      :type - midpoint: float
      :param - halfwidth: The half-width of the interval.
      :type - halfwidth: float

      :returns: The interval with midpoint and half-width.
      :rtype: - Interval

      .. rubric:: Example

      >>> pba.Interval.from_midwith(0,1)
      Interval [-1, 1]



.. py:data:: I

.. py:function:: PM(x, hw)

   Create an interval centered around x with a half-width of hw.

   # TODO: a constructor for creating an interval from a midpoint and half-width
   # ! this func is weird and I keep it only for not breaking the code in other places.

   **Parameters**:

       ``x`` (float): The center value of the interval.

       ``hw`` (float): The half-width of the interval.

   **Returns**:

       ``Interval``: An interval object with lower bound x-hw and upper bound x+hw.

   .. error::

       ``ValueError``: If hw is less than 0.

   .. rubric:: Example

   >>> pba.PM(0, 1)
   Interval [-1, 1]


.. py:class:: Cbox(*args, **kwargs)

   Bases: :py:obj:`PyUncertainNumber.pba.pbox_base.Pbox`


   Confidence boxes (c-boxes) are imprecise generalisations of traditional confidence distributions

   They have a different interpretation to p-boxes but rely on the same underlying mathematics.
   As such in pba-for-python c-boxes inhert most of their methods from Pbox.

   :param Pbox: _description_
   :type Pbox: _type_


   .. py:method:: __repr__()


   .. py:attribute:: __str__


   .. py:method:: __add__(other)


   .. py:method:: __radd__(other)


   .. py:method:: add(other, method='f')

      Adds to Pbox to other using the defined dependency method





   .. py:method:: __sub__(other)


   .. py:method:: __rsub__(other)


   .. py:method:: sub(other, method='f')


   .. py:method:: __mul__(other)


   .. py:method:: __rmul__(other)


   .. py:method:: mul(other, method='f')


   .. py:method:: __truediv__(other)


   .. py:method:: __rtruediv__(other)


   .. py:method:: div(other, method='f')


   .. py:method:: __neg__()


   .. py:method:: recip()


.. py:class:: Pbox(left=None, right=None, steps=None, shape=None, mean_left=None, mean_right=None, var_left=None, var_right=None, interpolation='linear')

   not the main constructor BUT the base constructor


   .. py:attribute:: STEPS

      Leslie:
      - Essentially, from the code implementation, a Pbox object is defined by the left and right bounds (i.e. nd.arrays).
      - Advantage is that this unifies both parametric and non-parametric pboxes but disadvantage is it discards the parameter
      information of the bounds which we may desire in the case of Cbox.


   .. py:attribute:: left


   .. py:attribute:: right


   .. py:attribute:: steps


   .. py:attribute:: shape


   .. py:attribute:: mean_left


   .. py:attribute:: mean_right


   .. py:attribute:: var_left
      :value: 0



   .. py:attribute:: var_right


   .. py:method:: get_range()

      get the range for either a pbox or a distribution

      .. note:: - #! added by Leslie



   .. py:property:: rangel

      leslie defined range property


   .. py:method:: __repr__()


   .. py:attribute:: __str__


   .. py:method:: __iter__()


   .. py:method:: __neg__()


   .. py:method:: __lt__(other)


   .. py:method:: __rlt__(other)


   .. py:method:: __le__(other)


   .. py:method:: __rle__(other)


   .. py:method:: __gt__(other)


   .. py:method:: __rgt__(other)


   .. py:method:: __ge__(other)


   .. py:method:: __rge__(other)


   .. py:method:: __and__(other)


   .. py:method:: __rand__(other)


   .. py:method:: __or__(other)


   .. py:method:: __ror__(other)


   .. py:method:: __add__(other)


   .. py:method:: __radd__(other)


   .. py:method:: __sub__(other)


   .. py:method:: __rsub__(other)


   .. py:method:: __mul__(other)


   .. py:method:: __rmul__(other)


   .. py:method:: __pow__(other)


   .. py:method:: __rpow__(other)


   .. py:method:: __truediv__(other)


   .. py:method:: __rtruediv__(other)


   .. py:method:: lo()

      Returns the left-most value in the interval



   .. py:method:: hi()

      Returns the right-most value in the interval



   .. py:method:: _computemoments()


   .. py:method:: _checkmoments()


   .. py:method:: cut()


   .. py:method:: cuth(x)

      get the bounds on the cumulative probability associated with any x-value



   .. py:method:: cutv(p=0.5)

      get the bounds on the x-value at any particular probability level



   .. py:method:: _unary(*args, function=lambda x: x)


   .. py:method:: add(other: Union[Pbox, PyUncertainNumber.pba.interval.Interval, float, int], method='f') -> Pbox

      Adds to Pbox to other using the defined dependency method





   .. py:method:: pow(other: Union[Pbox, PyUncertainNumber.pba.interval.Interval, float, int], method='f') -> Pbox

      Raises a p-box to the power of other using the defined dependency method

      :param other: Pbox, Interval or numeric type
      :param method:

      :return: Pbox
      :rtype: Pbox




   .. py:method:: sub(other, method='f')


   .. py:method:: mul(other, method='f')


   .. py:method:: div(other, method='f')


   .. py:method:: exp()


   .. py:method:: sqrt()


   .. py:method:: recip()


   .. py:method:: lt(other, method='f')


   .. py:method:: le(other, method='f')


   .. py:method:: gt(other, method='f')


   .. py:method:: ge(other, method='f')


   .. py:method:: min(other, method='f')

      Returns a new Pbox object that represents the element-wise minimum of two Pboxes.

      :param - other: Another Pbox object or a numeric value.
      :param - method: Calculation method to determine the minimum. Can be one of 'f', 'p', 'o', 'i'.

      :returns: Pbox



   .. py:method:: max(other, method='f')


   .. py:method:: truncate(a, b, method='f')

      Equivalent to self.min(a,method).max(b,method)



   .. py:method:: env(other)

      .. _interval.env:

      Computes the envelope of two Pboxes.

      Parameters:
      - other: Pbox or numeric value
          The other Pbox or numeric value to compute the envelope with.

      Returns:
      - Pbox
          The envelope Pbox.

      Raises:
      - ArithmeticError: If both Pboxes have different number of steps.



   .. py:method:: logicaland(other, method='f')


   .. py:method:: logicalor(other, method='f')


   .. py:method:: get_interval(*args) -> PyUncertainNumber.pba.interval.Interval


   .. py:method:: get_probability(val) -> PyUncertainNumber.pba.interval.Interval


   .. py:method:: summary() -> str


   .. py:method:: mean() -> PyUncertainNumber.pba.interval.Interval

      Returns the mean of the pbox



   .. py:method:: median() -> PyUncertainNumber.pba.interval.Interval

      Returns the median of the distribution



   .. py:method:: support() -> PyUncertainNumber.pba.interval.Interval


   .. py:method:: get_x()

      returns the x values for plotting



   .. py:method:: get_y()

      returns the y values for plotting



   .. py:method:: straddles(N, endpoints=True) -> bool

      :param N: Number to check
      :type N: numeric
      :param endpoints: Whether to include the endpoints within the check
      :type endpoints: bool

      :returns: * *True* -- If :math:`\mathrm{left} \leq N \leq \mathrm{right}` (Assuming `endpoints=True`)
                * *False* -- Otherwise



   .. py:method:: straddles_zero(endpoints=True) -> bool

      Checks whether :math:`0` is within the p-box



   .. py:method:: imp(other)

      Returns the imposition of self with other



   .. py:method:: show(figax=None, now=True, title='', x_axis_label='x', **kwargs)


   .. py:attribute:: plot


   .. py:method:: display(title='', ax=None, style='simple', fill_color='lightgray', **kwargs)

      quickly plot the pba object

      # !Leslie defined plotting function



.. py:class:: Interval(left=None, right=None)

   An interval is an uncertain number for which only the endpoints are known, :math:`x=[a,b]`.
   This is interpreted as :math:`x` being between :math:`a` and :math:`b` but with no more information about the value of :math:`x`.

   Intervals embody epistemic uncertainty within PBA.

   Creation
   ________

   Intervals can be created using either of the following:

   .. code-block:: python

       >>> pba.Interval(0,1)
       Interval [0,1]
       >>> pba.I(2,3)
       Interval [2,3]

   .. tip::

       The shorthand ``I`` is an alias for ``Interval``

   Intervals can also be created from a single value ± half-width:

   >>> pba.PM(0,1)
   Interval [-1,1]

   By default intervals are displayed as ``Interval [a,b]`` where ``a`` and ``b`` are the left and right endpoints respectively. This can be changed using the `interval.pm_repr`_ and `interval.lr_repr`_ functions.

   Arithmetic
   __________

   For two intervals [a,b] and [c,d] the following arithmetic operations are defined:

   **Addition**

   :math:`[a,b] + [c,d] = [a+c,b+d]`

   **Subtraction**

   :math:`[a,b] - [c,d] = [a-d,b-c]`

   **Multiplication**

   :math:`[a,b] * [c,d] = [\min(ac,ad,bc,bd),\max(ac,ad,bc,bd)]`

   **Division**

   :math:`[a,b] / [c,d] = [a,b] * \frac{1}{[c,d]} \equiv [\min(a/c,a/d,b/c,b/d),\max(a/c,a/d,b/c,b/d)]`

   Alternative arithmetic methods are described in `interval.add`_, `interval.sub`_, `interval.mul`_, `interval.div`_.



   .. py:attribute:: _left


   .. py:attribute:: _right


   .. py:property:: left


   .. py:property:: right


   .. py:method:: __repr__() -> str


   .. py:method:: __str__() -> str


   .. py:method:: __format__(format_spec: str) -> str


   .. py:method:: __iter__()


   .. py:method:: __len__()


   .. py:method:: __radd__(left)


   .. py:method:: __sub__(other)


   .. py:method:: __rsub__(other)


   .. py:method:: __neg__()


   .. py:method:: __mul__(other)


   .. py:method:: __rmul__(other)


   .. py:method:: __truediv__(other)


   .. py:method:: __rtruediv__(other)


   .. py:method:: __pow__(other)


   .. py:method:: __rpow__(left)


   .. py:method:: __lt__(other)


   .. py:method:: __rgt__(other)


   .. py:method:: __eq__(other)

      ==



   .. py:method:: __gt__(other)

      >



   .. py:method:: __rlt__(other)


   .. py:method:: __ne__(other)

      !=



   .. py:method:: __le__(other)

      <=



   .. py:method:: __ge__(other)


   .. py:method:: __bool__()


   .. py:method:: __abs__()


   .. py:method:: __contains__(other)


   .. py:method:: add(other, method=None)

      .. _interval.add:

      Adds the interval and another object together.


      **Args**:

          ``other``: The interval or numeric value to be added. This value must be transformable into an Interval object.

      **Methods**:

          p - perfect arithmetic :math:`[a,b]+[c,d] = [a + c, b + d]`

          o - opposite arithmetic :math:`[a,b]+[c,d] = [a + d, b + c]`

          None, i, f - Standard interval arithmetic is used.

      **Returns**:

          ``Interval``




   .. py:method:: __add__(other)


   .. py:method:: padd(other)

      .. warning::
          This method is deprecated. Use add(other, method='p') instead.



   .. py:method:: oadd(other)

      .. warning::
          This method is deprecated. Use add(other, method='o') instead.



   .. py:method:: sub(other, method=None)

      .. _interval.sub:

      Subtracts other from self.

      **Args**:

          ``other``: The interval or numeric value to be subracted. This value must be transformable into an Interval object.

      **Methods**:

          ``p``: perfect arithmetic :math:`a+b = [a.left - b.left, a.right - b.right]`

          ``o``: opposite arithmetic :math:`a+b = [a.left - b.right, a.right - b.left]`

          None, i, f - Standard interval arithmetic is used.

      **Returns**:

          ``Interval``




   .. py:method:: psub(other)

      .. warning::
          Depreciated use self.sub(other, method = 'p') instead



   .. py:method:: osub(other)

      .. warning::
          Depreciated use self.sub(other, method = 'o') instead



   .. py:method:: mul(other, method=None)

      .. _interval.mul:

      Multiplies self by other.

      **Args**:

          ``other``: The interval or numeric value to be multiplied. This value must be transformable into an Interval object.


      **Methods**:
          ``p``: perfect arithmetic :math:`[a,b],[c,d] = [a * c, b * d]`

          ``o``: opposite arithmetic :math:`[a,b],[c,d] = [a * d, b * c]`

          None, i, f - Standard interval arithmetic is used.

      **Returns**:
          Interval: The result of the multiplication.





   .. py:method:: pmul(other)

      .. warning::
          Depreciated use self.mul(other, method = 'p') instead



   .. py:method:: omul(other)

      .. warning::
          Depreciated use self.mul(other, method = 'o') instead



   .. py:method:: div(other, method=None)

      .. _interval.div:

      Divides self by other


      If :math:`0 \in other` it returns a division by zero error


      **Args**:

          ``other`` (Interval or numeric): The interval or numeric value to be multiplied. This value must be transformable into an Interval object.

      **Methods**:

          ``p``: perfect arithmetic :math:`[a,b],[c,d] = [a * 1/c, b * 1/d]`

          ``o``: opposite arithmetic :math:`[a,b],[c,d] = [a * 1/d, b * 1/c]`

          ``None``, ``i``, ``f`` - Standard interval arithmetic is used.

      .. admonition:: Implementation

          >>> self.add(1/other, method = method)

      .. error::

          If :math:`0 \in [a,b]` it returns a division by zero error




   .. py:method:: pdiv(other)

      .. warning::
          Depreciated use self.div(other, method = 'p') instead



   .. py:method:: odiv(other)

      .. warning::
          Depreciated use self.div(other, method = 'o') instead




   .. py:method:: recip()

      Calculates the reciprocle of the interval.

      **Returns**:

          ``Interval``: Equal to :math:`[1/b,1/a]`

      **Example**:

          >>> pba.Interval(2,4).recip()
          Interval [0.25, 0.5]

      .. error::
          If :math:`0 \in [a,b]` it returns a division by zero error




   .. py:method:: equiv(other: Interval) -> bool

      Checks whether two intervals are equivalent.

      **Parameters**:

          ``other``: The interval to check against.

      **Returns** ``True`` **if**:

          ``self.left == other.right`` and ``self.right == other.right``

          ``False`` otherwise.

      .. error::

          ``TypeError``: If ``other`` is not an instance of ``Interval``

      .. seealso::
          :func:`~logical.is_same_as`

      **Examples**:

          >>> a = Interval(0,1)
          >>> b = Interval(0.5,1.5)
          >>> c = I(0,1)
          >>> a.equiv(b)
          False
          >>> a.equiv(c)
          True




   .. py:method:: lo()

      **Returns**:
          ``self.left``

      .. tip::

          This function is redundant but exists to match Pbox class for possible internal reasons.




   .. py:method:: hi()

      **Returns**:
          ``self.right``

      .. tip::

          This function is redundant but exists to match Pbox class for possible internal reasons.




   .. py:method:: width() -> float

      **Returns**:

          ``float``: The width of the interval, :math:`\mathrm{right} - \mathrm{left}`

      **Example**:

          >>> pba.Interval(0,3).width()
          3




   .. py:method:: halfwidth() -> float

      **Returns**:

          ``float``: The half-width of the interval, :math:`(\mathrm{right} - \mathrm{left})/2`

      **Example**:

          >>> pba.Interval(0,3).halfwidth()
          1.5

      .. admonition:: Implementation

          >>> self.width()/2




   .. py:method:: midpoint() -> float

      Returns the midpoint of the interval

      .. note:: - this serves as the deterministic value representation of the interval, a.k.a. the naked value for an interval

      :returns: The midpoint of the interval, :math:`(\mathrm{right} + \mathrm{left})/2`
      :rtype: ``float``

      **Example**:
              >>> pba.Interval(0,2).midpoint()
              1.0



   .. py:method:: to_logical()

      Turns the interval into a logical interval, this is done by chacking the truth value of the ends of the interval

      **Returns**:

          ``Logical``: The logical interval

      .. admonition:: Implementation

          >>> left = self.left.__bool__()
          >>> right = self.right.__bool__()
          >>> Logical(left,right)





   .. py:method:: env(other: Union[list, Interval]) -> Interval

      Calculates the envelope between two intervals

      **Parameters**:

          ``other`` : Interval or list. The interval to envelope with self

      .. hint::

          If other is a list then the envelope is calculated between self and each element of the list. In this case the envelope is calculated recursively and pba.envelope() may be more efficient.

      .. important::
          If other is a Pbox then ``Pbox.env()`` is called

      .. seealso::

          `pba.core.envelope`_

          `pba.pbox.Pbox.env`_

      **Returns**:

          ``Interval``: The envelope of self and other





   .. py:method:: straddles(N: Union[int, float, Interval], endpoints: bool = True) -> bool

      .. _interval.straddles:

      **Parameters**:

          ``N``: Number to check. If N is an interval checks whether the whole interval is within self.

          ``endpoints``: Whether to include the endpoints within the check

      **Returns** ``True`` **if**:

          :math:`\mathrm{left} \leq N \leq \mathrm{right}` (Assuming ``endpoints=True``).

          For interval values. :math:`\mathrm{left} \leq N.left \leq \mathrm{right}` and :math:`\mathrm{left} \leq N.right \leq \mathrm{right}` (Assuming ``endpoints=True``).

          ``False`` otherwise.

      .. tip::

          ``N in self`` is equivalent to ``self.straddles(N)``




   .. py:method:: straddles_zero(endpoints=True)

      Checks whether :math:`0` is within the interval

      .. admonition:: Implementation

          Equivalent to ``self.straddles(0,endpoints)``

      .. seealso::
          interval.straddles_




   .. py:method:: intersection(other: Union[Interval, list]) -> Interval

      Calculates the intersection between intervals

      **Parameters**:

          ``other``: The interval to intersect with self. If an interval is not given will try to cast as an interval. If a list is given will calculate the intersection between self and each element of the list.

      **Returns**:

          ``Interval``: The intersection of self and other. If no intersection is found returns ``None``

      **Example**:

          >>> a = Interval(0,1)
          >>> b = Interval(0.5,1.5)
          >>> a.intersection(b)
          Interval [0.5, 1]



   .. py:method:: exp()


   .. py:method:: log()


   .. py:method:: sqrt()


   .. py:method:: display(title='', ax=None, style='simple', **kwargs)


   .. py:method:: sample(seed=None, numpy_rng: numpy.random.Generator = None) -> float

      Generate a random sample within the interval.

      **Parameters**:

          ``seed`` (int, optional): Seed value for random number generation. Defaults to None.

          ``numpy_rng`` (numpy.random.Generator, optional): Numpy random number generator. Defaults to None.

      **Returns**:

          ``float``: Random sample within the interval.

      .. admonition:: Implementation

          If ``numpy_rng`` is given:

              >>> numpy_rng.uniform(self.left, self.right)

          Otherwise the following is used:

          >>> import random
          >>> random.seed(seed)
          >>> self.left + random.random() * self.width()

      **Examples**:

          >>> pba.Interval(0,1).sample()
          0.6160988752201705
          >>> pba.I(0,1).sample(seed = 1)
          0.13436424411240122

      If a numpy random number generator is given then it is used instead of the default python random number generator. It has to be initialised first.

          >>> import numpy as np
          >>> rng = np.random.default_rng(seed = 0)
          >>> pba.I(0,1).sample(numpy_rng = rng)
          0.6369616873214543



   .. py:method:: from_midwith(midpoint: float, halfwidth: float) -> Interval
      :classmethod:


      Creates an Interval object from a midpoint and half-width.

      :param - midpoint: The midpoint of the interval.
      :type - midpoint: float
      :param - halfwidth: The half-width of the interval.
      :type - halfwidth: float

      :returns: The interval with midpoint and half-width.
      :rtype: - Interval

      .. rubric:: Example

      >>> pba.Interval.from_midwith(0,1)
      Interval [-1, 1]



.. py:class:: Logical(left: bool, right: bool = None)

   Bases: :py:obj:`PyUncertainNumber.pba.interval.Interval`


   Represents a logical value that can be either True or False or dunno ([False,True]).

   Inherits from the Interval class.

   **Attributes**:

       ``left`` (``bool``): The left endpoint of the logical value.

       ``right`` (``bool``): The right endpoint of the logical value.



   .. py:method:: __bool__()


   .. py:method:: __repr__()


   .. py:attribute:: __str__


   .. py:method:: __invert__()


.. py:function:: is_same_as(a: Union[PyUncertainNumber.pba.pbox_base.Pbox, PyUncertainNumber.pba.interval.Interval], b: Union[PyUncertainNumber.pba.pbox_base.Pbox, PyUncertainNumber.pba.interval.Interval], deep=False, exact_pbox=True)

   Check if two objects of type 'Pbox' or 'Interval' are equal.

   **Parameters**:

       ``a``: The first object to be compared.

       ``b``: The second object to be compared.

       ``deep``: If True, performs a deep comparison, considering object identity. If False, performs a shallow comparison based on object attributes. Defaults to False.

       ``exact_pbox``: If True, performs a deep comparison of p-boxes, considering all attributes. If False, performs a shallow comparison of p-boxes, considering only the left and right attributes. Defaults to True.

   **Returns** ``True`` **if**:

       ``bool``: True if the objects have identical parameters. For Intervals this means that left and right are the same for both a and b. For p-boxes checks whether all p-box attributes are the same. If deep is True, checks whether the objects have the same id.

   **Examples**:

       >>> a = Interval(0, 2)
       >>> b = Interval(0, 2)
       >>> c = Interval(1, 3)
       >>> is_same_as(a, b)
       True
       >>> is_same_as(a, c)
       False

   For p-boxes:

       >>> a = pba.N([0,1],1)
       >>> b = pba.N([0,1],1)
       >>> c = pba.N([0,1],2)
       >>> is_same_as(a, b)
       True
       >>> is_same_as(a, c)
       False
       >>> e = pba.box(0,1,steps=2)
       >>> f = Pbox(left = [0,0],right=[1,1],steps=2)
       >>> is_same_as(e, f, exact_pbox = True)
       False
       >>> is_same_as(e, f, exact_pbox = False)
       True




.. py:function:: always(logical: Union[Logical, PyUncertainNumber.pba.interval.Interval, numbers.Number, bool]) -> bool

   Checks whether the logical value is always true. i.e. Every value from one interval or p-box is always greater than any other values from another.

   This function takes either a Logical object, an interval or a float as input and checks if
   both the left and right attributes of the Logical object are True.
   If an interval is provided, it checks that both the left and right attributes of the Logical object are 1.
   If a numeric value is provided, it checks if the is equal to 1.

   **Parameters**:
       ``logical`` (``Logical``, ``Interval`` , ``Number``): An object representing a logical condition with 'left' and 'right' attributes, or a number between 0 and 1.

   **Returns**:
       ``bool``: True if both sides of the logical condition are True or if the float value is equal to 1, False otherwise.

   .. error::

       ``TypeError``: If the input is not an instance of Interval, Logical or a numeric value.

       ``ValueError``: If the input float is not between 0 and 1 or the interval contains values outside of [0,1]

   **Examples**:
       >>> a = Interval(0, 2)
       >>> b = Interval(1, 3)
       >>> c = Interval(4, 5)
       >>> always(a < b)
       False
       >>> always(a < c)
       True



.. py:function:: never(logical: Logical) -> bool

   Checks whether the logical value is always true. i.e. Every value from one interval or p-box is always less than any other values from another.

   This function takes either a Logical object, an interval or a float as input and checks if
   both the left and right attributes of the Logical object are False.
   If an interval is provided, it checks that both the left and right attributes of the Logical object are 0.
   If a numeric value is provided, it checks if the is equal to 0.

   **Parameters**:

       ``logical`` (``Logical``, ``Interval`` , ``Number``): An object representing a logical condition with 'left' and 'right' attributes, or a number between 0 and 1.

   **Returns**:

       ``bool``: True if both sides of the logical condition are True or if the float value is equal to 0, False otherwise.

   .. error::

       ``TypeError``: If the input is not an instance of Interval, Logical or a numeric value.

       ``ValueError``: If the input float is not between 0 and 1 or the interval contains values outside of [0,1]

   **Examples**:

       >>> a = Interval(0, 2)
       >>> b = Interval(1, 3)
       >>> c = Interval(4, 5)
       >>> never(a < b)
       False
       >>> never(a < c)
       True



.. py:function:: sometimes(logical: Logical) -> bool

   Checks whether the logical value is sometimes true. i.e. There exists one value from one interval or p-box is less than a values from another.

   This function takes either a Logical object, an interval or a float as input and checks if
   either the left and right attributes of the Logical object are True.
   If an interval is provided, it that both endpoints are not 0.
   If a numeric value is provided, it checks if the is not equal to 0.

   **Parameters**:

       ``logical`` (``Logical``, ``Interval`` , ``Number``): An object representing a logical condition with 'left' and 'right' attributes, or a number between 0 and 1.

   **Returns**:

       ``bool``: True if both sides of the logical condition are True or if the float value is equal to 0, False otherwise.

   .. error::

       ``TypeError``: If the input is not an instance of Interval, Logical or a numeric value.

       ``ValueError``: If the input float is not between 0 and 1 or the interval contains values outside of [0,1]

   **Examples**:

       >>> a = pba.Interval(0, 2)
       >>> b = pba.Interval(1, 4)
       >>> c = pba.Interval(3, 5)
       >>> pba.sometimes(a < b)
       True
       >>> pba.sometimes(a < c)
       True
       >>> pba.sometimes(c < b)
       True



.. py:function:: xtimes(logical: Logical) -> bool

   Checks whether the logical value is exclusively sometimes true. i.e. There exists one value from one interval or p-box is less than a values from another but it is not always the case.

   This function takes either a Logical object, an interval or a float as input and checks that the left value is False and the right value is True
   If an interval is provided, it that both endpoints are not 0 or 1.
   If a numeric value is provided, it checks if the is not equal to 0 or 1.

   **Parameters**:

       ``logical`` (``Logical``, ``Interval`` , ``Number``): An object representing a logical condition with 'left' and 'right' attributes, or a number between 0 and 1.

   **Returns**:

       ``bool``: True if both sides of the logical condition are True or if the float value is equal to 0, False otherwise.

   .. error::

       ``TypeError``: If the input is not an instance of Interval, Logical or a numeric value.

       ``ValueError``: If the input float is not between 0 and 1 or the interval contains values outside of [0,1]

   **Examples**:

       >>> a = pba.Interval(0, 2)
       >>> b = pba.Interval(2, 4)
       >>> c = pba.Interval(2.5,3.5)
       >>> pba.xtimes(a < b)
       False
       >>> pba.xtimes(a < c)
       False
       >>> pba.xtimes(c < b)
       True



.. py:class:: Params

   .. py:attribute:: steps
      :value: 200



   .. py:attribute:: many
      :value: 2000



   .. py:attribute:: p_values


   .. py:attribute:: p_lboundary
      :value: 0.0001



   .. py:attribute:: p_hboundary
      :value: 0.9999



   .. py:attribute:: s
      :value: [4.02, 4.07, 4.25, 4.32, 4.36, 4.45, 4.47, 4.57, 4.58, 4.62, 4.68, 4.71, 4.72, 4.79, 4.85, 4.86,...



   .. py:attribute:: scott_hedged_interpretation


   .. py:attribute:: user_hedged_interpretation


.. py:class:: Interval(left=None, right=None)

   An interval is an uncertain number for which only the endpoints are known, :math:`x=[a,b]`.
   This is interpreted as :math:`x` being between :math:`a` and :math:`b` but with no more information about the value of :math:`x`.

   Intervals embody epistemic uncertainty within PBA.

   Creation
   ________

   Intervals can be created using either of the following:

   .. code-block:: python

       >>> pba.Interval(0,1)
       Interval [0,1]
       >>> pba.I(2,3)
       Interval [2,3]

   .. tip::

       The shorthand ``I`` is an alias for ``Interval``

   Intervals can also be created from a single value ± half-width:

   >>> pba.PM(0,1)
   Interval [-1,1]

   By default intervals are displayed as ``Interval [a,b]`` where ``a`` and ``b`` are the left and right endpoints respectively. This can be changed using the `interval.pm_repr`_ and `interval.lr_repr`_ functions.

   Arithmetic
   __________

   For two intervals [a,b] and [c,d] the following arithmetic operations are defined:

   **Addition**

   :math:`[a,b] + [c,d] = [a+c,b+d]`

   **Subtraction**

   :math:`[a,b] - [c,d] = [a-d,b-c]`

   **Multiplication**

   :math:`[a,b] * [c,d] = [\min(ac,ad,bc,bd),\max(ac,ad,bc,bd)]`

   **Division**

   :math:`[a,b] / [c,d] = [a,b] * \frac{1}{[c,d]} \equiv [\min(a/c,a/d,b/c,b/d),\max(a/c,a/d,b/c,b/d)]`

   Alternative arithmetic methods are described in `interval.add`_, `interval.sub`_, `interval.mul`_, `interval.div`_.



   .. py:attribute:: _left


   .. py:attribute:: _right


   .. py:property:: left


   .. py:property:: right


   .. py:method:: __repr__() -> str


   .. py:method:: __str__() -> str


   .. py:method:: __format__(format_spec: str) -> str


   .. py:method:: __iter__()


   .. py:method:: __len__()


   .. py:method:: __radd__(left)


   .. py:method:: __sub__(other)


   .. py:method:: __rsub__(other)


   .. py:method:: __neg__()


   .. py:method:: __mul__(other)


   .. py:method:: __rmul__(other)


   .. py:method:: __truediv__(other)


   .. py:method:: __rtruediv__(other)


   .. py:method:: __pow__(other)


   .. py:method:: __rpow__(left)


   .. py:method:: __lt__(other)


   .. py:method:: __rgt__(other)


   .. py:method:: __eq__(other)

      ==



   .. py:method:: __gt__(other)

      >



   .. py:method:: __rlt__(other)


   .. py:method:: __ne__(other)

      !=



   .. py:method:: __le__(other)

      <=



   .. py:method:: __ge__(other)


   .. py:method:: __bool__()


   .. py:method:: __abs__()


   .. py:method:: __contains__(other)


   .. py:method:: add(other, method=None)

      .. _interval.add:

      Adds the interval and another object together.


      **Args**:

          ``other``: The interval or numeric value to be added. This value must be transformable into an Interval object.

      **Methods**:

          p - perfect arithmetic :math:`[a,b]+[c,d] = [a + c, b + d]`

          o - opposite arithmetic :math:`[a,b]+[c,d] = [a + d, b + c]`

          None, i, f - Standard interval arithmetic is used.

      **Returns**:

          ``Interval``




   .. py:method:: __add__(other)


   .. py:method:: padd(other)

      .. warning::
          This method is deprecated. Use add(other, method='p') instead.



   .. py:method:: oadd(other)

      .. warning::
          This method is deprecated. Use add(other, method='o') instead.



   .. py:method:: sub(other, method=None)

      .. _interval.sub:

      Subtracts other from self.

      **Args**:

          ``other``: The interval or numeric value to be subracted. This value must be transformable into an Interval object.

      **Methods**:

          ``p``: perfect arithmetic :math:`a+b = [a.left - b.left, a.right - b.right]`

          ``o``: opposite arithmetic :math:`a+b = [a.left - b.right, a.right - b.left]`

          None, i, f - Standard interval arithmetic is used.

      **Returns**:

          ``Interval``




   .. py:method:: psub(other)

      .. warning::
          Depreciated use self.sub(other, method = 'p') instead



   .. py:method:: osub(other)

      .. warning::
          Depreciated use self.sub(other, method = 'o') instead



   .. py:method:: mul(other, method=None)

      .. _interval.mul:

      Multiplies self by other.

      **Args**:

          ``other``: The interval or numeric value to be multiplied. This value must be transformable into an Interval object.


      **Methods**:
          ``p``: perfect arithmetic :math:`[a,b],[c,d] = [a * c, b * d]`

          ``o``: opposite arithmetic :math:`[a,b],[c,d] = [a * d, b * c]`

          None, i, f - Standard interval arithmetic is used.

      **Returns**:
          Interval: The result of the multiplication.





   .. py:method:: pmul(other)

      .. warning::
          Depreciated use self.mul(other, method = 'p') instead



   .. py:method:: omul(other)

      .. warning::
          Depreciated use self.mul(other, method = 'o') instead



   .. py:method:: div(other, method=None)

      .. _interval.div:

      Divides self by other


      If :math:`0 \in other` it returns a division by zero error


      **Args**:

          ``other`` (Interval or numeric): The interval or numeric value to be multiplied. This value must be transformable into an Interval object.

      **Methods**:

          ``p``: perfect arithmetic :math:`[a,b],[c,d] = [a * 1/c, b * 1/d]`

          ``o``: opposite arithmetic :math:`[a,b],[c,d] = [a * 1/d, b * 1/c]`

          ``None``, ``i``, ``f`` - Standard interval arithmetic is used.

      .. admonition:: Implementation

          >>> self.add(1/other, method = method)

      .. error::

          If :math:`0 \in [a,b]` it returns a division by zero error




   .. py:method:: pdiv(other)

      .. warning::
          Depreciated use self.div(other, method = 'p') instead



   .. py:method:: odiv(other)

      .. warning::
          Depreciated use self.div(other, method = 'o') instead




   .. py:method:: recip()

      Calculates the reciprocle of the interval.

      **Returns**:

          ``Interval``: Equal to :math:`[1/b,1/a]`

      **Example**:

          >>> pba.Interval(2,4).recip()
          Interval [0.25, 0.5]

      .. error::
          If :math:`0 \in [a,b]` it returns a division by zero error




   .. py:method:: equiv(other: Interval) -> bool

      Checks whether two intervals are equivalent.

      **Parameters**:

          ``other``: The interval to check against.

      **Returns** ``True`` **if**:

          ``self.left == other.right`` and ``self.right == other.right``

          ``False`` otherwise.

      .. error::

          ``TypeError``: If ``other`` is not an instance of ``Interval``

      .. seealso::
          :func:`~logical.is_same_as`

      **Examples**:

          >>> a = Interval(0,1)
          >>> b = Interval(0.5,1.5)
          >>> c = I(0,1)
          >>> a.equiv(b)
          False
          >>> a.equiv(c)
          True




   .. py:method:: lo()

      **Returns**:
          ``self.left``

      .. tip::

          This function is redundant but exists to match Pbox class for possible internal reasons.




   .. py:method:: hi()

      **Returns**:
          ``self.right``

      .. tip::

          This function is redundant but exists to match Pbox class for possible internal reasons.




   .. py:method:: width() -> float

      **Returns**:

          ``float``: The width of the interval, :math:`\mathrm{right} - \mathrm{left}`

      **Example**:

          >>> pba.Interval(0,3).width()
          3




   .. py:method:: halfwidth() -> float

      **Returns**:

          ``float``: The half-width of the interval, :math:`(\mathrm{right} - \mathrm{left})/2`

      **Example**:

          >>> pba.Interval(0,3).halfwidth()
          1.5

      .. admonition:: Implementation

          >>> self.width()/2




   .. py:method:: midpoint() -> float

      Returns the midpoint of the interval

      .. note:: - this serves as the deterministic value representation of the interval, a.k.a. the naked value for an interval

      :returns: The midpoint of the interval, :math:`(\mathrm{right} + \mathrm{left})/2`
      :rtype: ``float``

      **Example**:
              >>> pba.Interval(0,2).midpoint()
              1.0



   .. py:method:: to_logical()

      Turns the interval into a logical interval, this is done by chacking the truth value of the ends of the interval

      **Returns**:

          ``Logical``: The logical interval

      .. admonition:: Implementation

          >>> left = self.left.__bool__()
          >>> right = self.right.__bool__()
          >>> Logical(left,right)





   .. py:method:: env(other: Union[list, Interval]) -> Interval

      Calculates the envelope between two intervals

      **Parameters**:

          ``other`` : Interval or list. The interval to envelope with self

      .. hint::

          If other is a list then the envelope is calculated between self and each element of the list. In this case the envelope is calculated recursively and pba.envelope() may be more efficient.

      .. important::
          If other is a Pbox then ``Pbox.env()`` is called

      .. seealso::

          `pba.core.envelope`_

          `pba.pbox.Pbox.env`_

      **Returns**:

          ``Interval``: The envelope of self and other





   .. py:method:: straddles(N: Union[int, float, Interval], endpoints: bool = True) -> bool

      .. _interval.straddles:

      **Parameters**:

          ``N``: Number to check. If N is an interval checks whether the whole interval is within self.

          ``endpoints``: Whether to include the endpoints within the check

      **Returns** ``True`` **if**:

          :math:`\mathrm{left} \leq N \leq \mathrm{right}` (Assuming ``endpoints=True``).

          For interval values. :math:`\mathrm{left} \leq N.left \leq \mathrm{right}` and :math:`\mathrm{left} \leq N.right \leq \mathrm{right}` (Assuming ``endpoints=True``).

          ``False`` otherwise.

      .. tip::

          ``N in self`` is equivalent to ``self.straddles(N)``




   .. py:method:: straddles_zero(endpoints=True)

      Checks whether :math:`0` is within the interval

      .. admonition:: Implementation

          Equivalent to ``self.straddles(0,endpoints)``

      .. seealso::
          interval.straddles_




   .. py:method:: intersection(other: Union[Interval, list]) -> Interval

      Calculates the intersection between intervals

      **Parameters**:

          ``other``: The interval to intersect with self. If an interval is not given will try to cast as an interval. If a list is given will calculate the intersection between self and each element of the list.

      **Returns**:

          ``Interval``: The intersection of self and other. If no intersection is found returns ``None``

      **Example**:

          >>> a = Interval(0,1)
          >>> b = Interval(0.5,1.5)
          >>> a.intersection(b)
          Interval [0.5, 1]



   .. py:method:: exp()


   .. py:method:: log()


   .. py:method:: sqrt()


   .. py:method:: display(title='', ax=None, style='simple', **kwargs)


   .. py:method:: sample(seed=None, numpy_rng: numpy.random.Generator = None) -> float

      Generate a random sample within the interval.

      **Parameters**:

          ``seed`` (int, optional): Seed value for random number generation. Defaults to None.

          ``numpy_rng`` (numpy.random.Generator, optional): Numpy random number generator. Defaults to None.

      **Returns**:

          ``float``: Random sample within the interval.

      .. admonition:: Implementation

          If ``numpy_rng`` is given:

              >>> numpy_rng.uniform(self.left, self.right)

          Otherwise the following is used:

          >>> import random
          >>> random.seed(seed)
          >>> self.left + random.random() * self.width()

      **Examples**:

          >>> pba.Interval(0,1).sample()
          0.6160988752201705
          >>> pba.I(0,1).sample(seed = 1)
          0.13436424411240122

      If a numpy random number generator is given then it is used instead of the default python random number generator. It has to be initialised first.

          >>> import numpy as np
          >>> rng = np.random.default_rng(seed = 0)
          >>> pba.I(0,1).sample(numpy_rng = rng)
          0.6369616873214543



   .. py:method:: from_midwith(midpoint: float, halfwidth: float) -> Interval
      :classmethod:


      Creates an Interval object from a midpoint and half-width.

      :param - midpoint: The midpoint of the interval.
      :type - midpoint: float
      :param - halfwidth: The half-width of the interval.
      :type - halfwidth: float

      :returns: The interval with midpoint and half-width.
      :rtype: - Interval

      .. rubric:: Example

      >>> pba.Interval.from_midwith(0,1)
      Interval [-1, 1]



.. py:class:: Pbox(left=None, right=None, steps=None, shape=None, mean_left=None, mean_right=None, var_left=None, var_right=None, interpolation='linear')

   not the main constructor BUT the base constructor


   .. py:attribute:: STEPS

      Leslie:
      - Essentially, from the code implementation, a Pbox object is defined by the left and right bounds (i.e. nd.arrays).
      - Advantage is that this unifies both parametric and non-parametric pboxes but disadvantage is it discards the parameter
      information of the bounds which we may desire in the case of Cbox.


   .. py:attribute:: left


   .. py:attribute:: right


   .. py:attribute:: steps


   .. py:attribute:: shape


   .. py:attribute:: mean_left


   .. py:attribute:: mean_right


   .. py:attribute:: var_left
      :value: 0



   .. py:attribute:: var_right


   .. py:method:: get_range()

      get the range for either a pbox or a distribution

      .. note:: - #! added by Leslie



   .. py:property:: rangel

      leslie defined range property


   .. py:method:: __repr__()


   .. py:attribute:: __str__


   .. py:method:: __iter__()


   .. py:method:: __neg__()


   .. py:method:: __lt__(other)


   .. py:method:: __rlt__(other)


   .. py:method:: __le__(other)


   .. py:method:: __rle__(other)


   .. py:method:: __gt__(other)


   .. py:method:: __rgt__(other)


   .. py:method:: __ge__(other)


   .. py:method:: __rge__(other)


   .. py:method:: __and__(other)


   .. py:method:: __rand__(other)


   .. py:method:: __or__(other)


   .. py:method:: __ror__(other)


   .. py:method:: __add__(other)


   .. py:method:: __radd__(other)


   .. py:method:: __sub__(other)


   .. py:method:: __rsub__(other)


   .. py:method:: __mul__(other)


   .. py:method:: __rmul__(other)


   .. py:method:: __pow__(other)


   .. py:method:: __rpow__(other)


   .. py:method:: __truediv__(other)


   .. py:method:: __rtruediv__(other)


   .. py:method:: lo()

      Returns the left-most value in the interval



   .. py:method:: hi()

      Returns the right-most value in the interval



   .. py:method:: _computemoments()


   .. py:method:: _checkmoments()


   .. py:method:: cut()


   .. py:method:: cuth(x)

      get the bounds on the cumulative probability associated with any x-value



   .. py:method:: cutv(p=0.5)

      get the bounds on the x-value at any particular probability level



   .. py:method:: _unary(*args, function=lambda x: x)


   .. py:method:: add(other: Union[Pbox, PyUncertainNumber.pba.interval.Interval, float, int], method='f') -> Pbox

      Adds to Pbox to other using the defined dependency method





   .. py:method:: pow(other: Union[Pbox, PyUncertainNumber.pba.interval.Interval, float, int], method='f') -> Pbox

      Raises a p-box to the power of other using the defined dependency method

      :param other: Pbox, Interval or numeric type
      :param method:

      :return: Pbox
      :rtype: Pbox




   .. py:method:: sub(other, method='f')


   .. py:method:: mul(other, method='f')


   .. py:method:: div(other, method='f')


   .. py:method:: exp()


   .. py:method:: sqrt()


   .. py:method:: recip()


   .. py:method:: lt(other, method='f')


   .. py:method:: le(other, method='f')


   .. py:method:: gt(other, method='f')


   .. py:method:: ge(other, method='f')


   .. py:method:: min(other, method='f')

      Returns a new Pbox object that represents the element-wise minimum of two Pboxes.

      :param - other: Another Pbox object or a numeric value.
      :param - method: Calculation method to determine the minimum. Can be one of 'f', 'p', 'o', 'i'.

      :returns: Pbox



   .. py:method:: max(other, method='f')


   .. py:method:: truncate(a, b, method='f')

      Equivalent to self.min(a,method).max(b,method)



   .. py:method:: env(other)

      .. _interval.env:

      Computes the envelope of two Pboxes.

      Parameters:
      - other: Pbox or numeric value
          The other Pbox or numeric value to compute the envelope with.

      Returns:
      - Pbox
          The envelope Pbox.

      Raises:
      - ArithmeticError: If both Pboxes have different number of steps.



   .. py:method:: logicaland(other, method='f')


   .. py:method:: logicalor(other, method='f')


   .. py:method:: get_interval(*args) -> PyUncertainNumber.pba.interval.Interval


   .. py:method:: get_probability(val) -> PyUncertainNumber.pba.interval.Interval


   .. py:method:: summary() -> str


   .. py:method:: mean() -> PyUncertainNumber.pba.interval.Interval

      Returns the mean of the pbox



   .. py:method:: median() -> PyUncertainNumber.pba.interval.Interval

      Returns the median of the distribution



   .. py:method:: support() -> PyUncertainNumber.pba.interval.Interval


   .. py:method:: get_x()

      returns the x values for plotting



   .. py:method:: get_y()

      returns the y values for plotting



   .. py:method:: straddles(N, endpoints=True) -> bool

      :param N: Number to check
      :type N: numeric
      :param endpoints: Whether to include the endpoints within the check
      :type endpoints: bool

      :returns: * *True* -- If :math:`\mathrm{left} \leq N \leq \mathrm{right}` (Assuming `endpoints=True`)
                * *False* -- Otherwise



   .. py:method:: straddles_zero(endpoints=True) -> bool

      Checks whether :math:`0` is within the p-box



   .. py:method:: imp(other)

      Returns the imposition of self with other



   .. py:method:: show(figax=None, now=True, title='', x_axis_label='x', **kwargs)


   .. py:attribute:: plot


   .. py:method:: display(title='', ax=None, style='simple', fill_color='lightgray', **kwargs)

      quickly plot the pba object

      # !Leslie defined plotting function



.. py:data:: dists

.. py:function:: __get_bounds(function_name=None, steps=Params.steps, *args)

   heavy lifting function that returns the bounds of the distribution for defining pboxes

   :returns: (array-like or list) left-bound of the pbox
             Right: (array-like or list) right-bound of the pbox
             mean: (Interval) mean of the pbox
             var: (Interval) variance of the pbox
   :rtype: Left


.. py:function:: lognormal(mean, var, steps=Params.steps)

   Creates a p-box for the lognormal distribution

   *Note: the parameters used are the mean and variance of the lognormal distribution
   not the mean and variance of the underlying normal*
   See:
   `[1]<https://en.wikipedia.org/wiki/Log-normal_distribution#Generation_and_parameters>`
   `[2]<https://stackoverflow.com/questions/51906063/distribution-mean-and-standard-deviation-using-scipy-stats>`


   :param mean: mean of the lognormal distribution
   :param var: variance of the lognormal distribution

   :rtype: Pbox


.. py:function:: alpha(*args, steps=Params.steps)

.. py:function:: anglit(*args, steps=Params.steps)

.. py:function:: arcsine(*args, steps=Params.steps)

.. py:function:: argus(*args, steps=Params.steps)

.. py:function:: beta(*args, steps=Params.steps)

   Beta distribution


.. py:function:: betaprime(*args, steps=Params.steps)

.. py:function:: bradford(*args, steps=Params.steps)

.. py:function:: burr(*args, steps=Params.steps)

.. py:function:: burr12(*args, steps=Params.steps)

.. py:function:: cauchy(*args, steps=Params.steps)

.. py:function:: chi(*args, steps=Params.steps)

.. py:function:: chi2(*args, steps=Params.steps)

.. py:function:: cosine(*args, steps=Params.steps)

.. py:function:: crystalball(*args, steps=Params.steps)

.. py:function:: dgamma(*args, steps=Params.steps)

.. py:function:: dweibull(*args, steps=Params.steps)

.. py:function:: erlang(*args, steps=Params.steps)

.. py:function:: expon(*args, steps=Params.steps)

.. py:function:: exponnorm(*args, steps=Params.steps)

.. py:function:: exponweib(*args, steps=Params.steps)

.. py:function:: exponpow(*args, steps=Params.steps)

.. py:function:: f(*args, steps=Params.steps)

.. py:function:: fatiguelife(*args, steps=Params.steps)

.. py:function:: fisk(*args, steps=Params.steps)

.. py:function:: foldcauchy(*args, steps=Params.steps)

.. py:function:: foldnorm(mu, s, steps=Params.steps)

.. py:function:: genlogistic(*args, steps=Params.steps)

.. py:function:: gennorm(*args, steps=Params.steps)

.. py:function:: genpareto(*args, steps=Params.steps)

.. py:function:: genexpon(*args, steps=Params.steps)

.. py:function:: genextreme(*args, steps=Params.steps)

.. py:function:: gausshyper(*args, steps=Params.steps)

.. py:function:: gamma(*args, steps=Params.steps)

.. py:function:: gengamma(*args, steps=Params.steps)

.. py:function:: genhalflogistic(*args, steps=Params.steps)

.. py:function:: geninvgauss(*args, steps=Params.steps)

.. py:function:: gompertz(*args, steps=Params.steps)

.. py:function:: gumbel_r(*args, steps=Params.steps)

.. py:function:: gumbel_l(*args, steps=Params.steps)

.. py:function:: halfcauchy(*args, steps=Params.steps)

.. py:function:: halflogistic(*args, steps=Params.steps)

.. py:function:: halfnorm(*args, steps=Params.steps)

.. py:function:: halfgennorm(*args, steps=Params.steps)

.. py:function:: hypsecant(*args, steps=Params.steps)

.. py:function:: invgamma(*args, steps=Params.steps)

.. py:function:: invgauss(*args, steps=Params.steps)

.. py:function:: invweibull(*args, steps=Params.steps)

.. py:function:: johnsonsb(*args, steps=Params.steps)

.. py:function:: johnsonsu(*args, steps=Params.steps)

.. py:function:: kappa4(*args, steps=Params.steps)

.. py:function:: kappa3(*args, steps=Params.steps)

.. py:function:: ksone(*args, steps=Params.steps)

.. py:function:: kstwobign(*args, steps=Params.steps)

.. py:function:: laplace(*args, steps=Params.steps)

.. py:function:: levy(*args, steps=Params.steps)

.. py:function:: levy_l(*args, steps=Params.steps)

.. py:function:: levy_stable(*args, steps=Params.steps)

.. py:function:: logistic(*args, steps=Params.steps)

.. py:function:: loggamma(*args, steps=Params.steps)

.. py:function:: loglaplace(*args, steps=Params.steps)

.. py:function:: loguniform(*args, steps=Params.steps)

.. py:function:: lomax(*args, steps=Params.steps)

.. py:function:: maxwell(*args, steps=Params.steps)

.. py:function:: mielke(*args, steps=Params.steps)

.. py:function:: moyal(*args, steps=Params.steps)

.. py:function:: nakagami(*args, steps=Params.steps)

.. py:function:: ncx2(*args, steps=Params.steps)

.. py:function:: ncf(*args, steps=Params.steps)

.. py:function:: nct(*args, steps=Params.steps)

.. py:function:: norm(*args, steps=Params.steps)

.. py:function:: norminvgauss(*args, steps=Params.steps)

.. py:function:: pareto(*args, steps=Params.steps)

.. py:function:: pearson3(*args, steps=Params.steps)

.. py:function:: powerlaw(*args, steps=Params.steps)

.. py:function:: powerlognorm(*args, steps=Params.steps)

.. py:function:: powernorm(*args, steps=Params.steps)

.. py:function:: rdist(*args, steps=Params.steps)

.. py:function:: rayleigh(*args, steps=Params.steps)

.. py:function:: rice(*args, steps=Params.steps)

.. py:function:: recipinvgauss(*args, steps=Params.steps)

.. py:function:: semicircular(*args, steps=Params.steps)

.. py:function:: skewnorm(*args, steps=Params.steps)

.. py:function:: t(*args, steps=Params.steps)

.. py:function:: trapz(a, b, c, d, steps=Params.steps)

.. py:function:: triang(*args, steps=Params.steps)

.. py:function:: truncexpon(*args, steps=Params.steps)

.. py:function:: truncnorm(left, right, mean=None, stddev=None, steps=Params.steps)

.. py:function:: tukeylambda(*args, steps=Params.steps)

.. py:function:: uniform(a, b, steps=Params.steps)

.. py:function:: vonmises(*args, steps=Pbox.STEPS)

.. py:function:: vonmises_line(*args, steps=Params.steps)

.. py:function:: wald(*args, steps=Params.steps)

.. py:function:: weibull_min(*args, steps=Params.steps)

.. py:function:: weibull_max(*args, steps=Params.steps)

.. py:function:: weibull(*args, steps=Params.steps)

.. py:function:: wrapcauchy(*args, steps=Params.steps)

.. py:function:: bernoulli(*args, steps=Params.steps)

.. py:function:: betabinom(*args, steps=Params.steps)

.. py:function:: binom(*args, steps=Params.steps)

.. py:function:: boltzmann(*args, steps=Params.steps)

.. py:function:: dlaplace(*args, steps=Params.steps)

.. py:function:: geom(*args, steps=Params.steps)

.. py:function:: hypergeom(*args, steps=Params.steps)

.. py:function:: logser(*args, steps=Params.steps)

.. py:function:: nbinom(*args, steps=Params.steps)

.. py:function:: planck(*args, steps=Params.steps)

.. py:function:: poisson(*args, steps=Params.steps)

.. py:function:: randint(*args, steps=Params.steps)

.. py:function:: skellam(*args, steps=Params.steps)

.. py:function:: zipf(*args, steps=Params.steps)

.. py:function:: yulesimon(*args, steps=Params.steps)

.. py:function:: KM(k, m, steps=Params.steps)

.. py:function:: KN(k, n, steps=Params.steps)

.. py:data:: named_pbox

.. py:data:: normal

.. py:data:: N

.. py:data:: unif

.. py:data:: U

.. py:data:: lognorm

.. py:function:: known_properties(minimum: Optional[Union[PyUncertainNumber.pba.logical.Interval, float, int]] = None, maximum: Optional[Union[PyUncertainNumber.pba.logical.Interval, float, int]] = None, mean: Optional[Union[PyUncertainNumber.pba.logical.Interval, float, int]] = None, median: Optional[Union[PyUncertainNumber.pba.logical.Interval, float, int]] = None, mode: Optional[Union[PyUncertainNumber.pba.logical.Interval, float, int]] = None, std: Optional[Union[PyUncertainNumber.pba.logical.Interval, float, int]] = None, var: Optional[Union[PyUncertainNumber.pba.logical.Interval, float, int]] = None, cv: Optional[Union[PyUncertainNumber.pba.logical.Interval, float, int]] = None, percentiles: Optional[dict[Union[PyUncertainNumber.pba.logical.Interval, float, int]]] = None, debug: bool = False, steps: int = Pbox.STEPS) -> PyUncertainNumber.pba.logical.Pbox

   Generates a distribution free p-box based upon the information given.
   This function works by calculating every possible non-parametric p-box that can be generated using the information provided.
   The returned p-box is the intersection of these p-boxes.

   **Parameters**:

       ``minimum``: Minimum value of the variable
       ``maximum``: Maximum value of the variable
       ``mean``: Mean value of the variable
       ``median``: Median value of the variable
       ``mode``: Mode value of the variable
       ``std``: Standard deviation of the variable
       ``var``: Variance of the variable
       ``cv``: Coefficient of variation of the variable
       ``percentiles``: Dictionary of percentiles and their values (e.g. {0.1: 1, 0.5: 2, 0.9: Interval(3,4)})
       ``steps``: Number of steps to use in the p-box

   .. error::

       ``ValueError``: If any of the arguments are not consistent with each other. (i.e. if ``std`` and ``var`` are both given, but ``std != sqrt(var)``)

   **Returns**:

       ``Pbox``: Imposition of possible p-boxes


.. py:function:: box(a: Union[PyUncertainNumber.pba.logical.Interval, float, int], b: Union[PyUncertainNumber.pba.logical.Interval, float, int] = None, steps=Pbox.STEPS, shape='box') -> PyUncertainNumber.pba.logical.Pbox

   Returns a box shaped Pbox. This is equivalent to an Interval expressed as a Pbox.

   **Parameters**:

       ``a`` : Left side of box
       ``b``: Right side of box


   **Returns**:

       ``Pbox``



.. py:data:: min_max

.. py:function:: min_max_mean(minimum: Union[PyUncertainNumber.pba.logical.Interval, float, int], maximum: Union[PyUncertainNumber.pba.logical.Interval, float, int], mean: Union[PyUncertainNumber.pba.logical.Interval, float, int], steps: int = Pbox.STEPS) -> PyUncertainNumber.pba.logical.Pbox

   Generates a distribution-free p-box based upon the minimum, maximum and mean of the variable

   **Parameters**:

       ``minimum`` : minimum value of the variable

       ``maximum`` : maximum value of the variable

       ``mean`` : mean value of the variable


   **Returns**:

       ``Pbox``


.. py:function:: min_mean(minimum: Union[PyUncertainNumber.pba.logical.Interval, float, int], mean: Union[PyUncertainNumber.pba.logical.Interval, float, int], steps=Pbox.STEPS) -> PyUncertainNumber.pba.logical.Pbox

   Generates a distribution-free p-box based upon the minimum and mean of the variable

   **Parameters**:

       ``minimum`` : minimum value of the variable

       ``mean`` : mean value of the variable


   **Returns**:

       ``Pbox``


.. py:function:: min_max_mean_std(minimum: Union[PyUncertainNumber.pba.logical.Interval, float, int], maximum: Union[PyUncertainNumber.pba.logical.Interval, float, int], mean: Union[PyUncertainNumber.pba.logical.Interval, float, int], std: Union[PyUncertainNumber.pba.logical.Interval, float, int], steps: int = Pbox.STEPS) -> PyUncertainNumber.pba.logical.Pbox

   Generates a distribution-free p-box based upon the minimum, maximum, mean and standard deviation of the variable

   **Parameters**

       ``minimum`` : minimum value of the variable
       ``maximum`` : maximum value of the variable
       ``mean`` : mean value of the variable
       ``std`` :standard deviation of the variable

   **Returns**

       ``Pbox``

   .. seealso::

       :func:`min_max_mean_var`



.. py:function:: min_max_mean_var(minimum: Union[PyUncertainNumber.pba.logical.Interval, float, int], maximum: Union[PyUncertainNumber.pba.logical.Interval, float, int], mean: Union[PyUncertainNumber.pba.logical.Interval, float, int], var: Union[PyUncertainNumber.pba.logical.Interval, float, int], steps: int = Pbox.STEPS) -> PyUncertainNumber.pba.logical.Pbox

   Generates a distribution-free p-box based upon the minimum, maximum, mean and standard deviation of the variable

   **Parameters**

       ``minimum`` : minimum value of the variable
       ``maximum`` : maximum value of the variable
       ``mean`` : mean value of the variable
       ``var`` :variance of the variable

   **Returns**

       ``Pbox``


   .. admonition:: Implementation

       Equivalent to ``min_max_mean_std(minimum,maximum,mean,np.sqrt(var))``

   .. seealso::

       :func:`min_max_mean_std`



.. py:function:: min_max_mode(minimum: Union[PyUncertainNumber.pba.logical.Interval, float, int], maximum: Union[PyUncertainNumber.pba.logical.Interval, float, int], mode: Union[PyUncertainNumber.pba.logical.Interval, float, int], steps: int = Pbox.STEPS) -> PyUncertainNumber.pba.logical.Pbox

   Generates a distribution-free p-box based upon the minimum, maximum, and mode of the variable

   **Parameters**:

       ``minimum`` : minimum value of the variable

       ``maximum`` : maximum value of the variable

       ``mode`` : mode value of the variable


   **Returns**:

       ``Pbox``



.. py:function:: min_max_median(minimum: Union[PyUncertainNumber.pba.logical.Interval, float, int], maximum: Union[PyUncertainNumber.pba.logical.Interval, float, int], median: Union[PyUncertainNumber.pba.logical.Interval, float, int], steps: int = Pbox.STEPS) -> PyUncertainNumber.pba.logical.Pbox

   Generates a distribution-free p-box based upon the minimum, maximum and median of the variable

   **Parameters**:

       ``minimum`` : minimum value of the variable

       ``maximum`` : maximum value of the variable

       ``median`` : median value of the variable


   **Returns**:

       ``Pbox``



.. py:function:: min_max_median_is_mode(minimum: Union[PyUncertainNumber.pba.logical.Interval, float, int], maximum: Union[PyUncertainNumber.pba.logical.Interval, float, int], m: Union[PyUncertainNumber.pba.logical.Interval, float, int], steps: int = Pbox.STEPS) -> PyUncertainNumber.pba.logical.Pbox

   Generates a distribution-free p-box based upon the minimum, maximum and median/mode of the variable when median = mode.

   **Parameters**:

       ``minimum`` : minimum value of the variable

       ``maximum`` : maximum value of the variable

       ``m`` : m = median = mode value of the variable


   **Returns**:

       ``Pbox``



.. py:function:: mean_std(mean: Union[PyUncertainNumber.pba.logical.Interval, float, int], std: Union[PyUncertainNumber.pba.logical.Interval, float, int], steps=Pbox.STEPS) -> PyUncertainNumber.pba.logical.Pbox

   Generates a distribution-free p-box based upon the mean and standard deviation of the variable

   **Parameters**:

       ``mean`` : mean of the variable

       ``std`` : standard deviation of the variable


   **Returns**:

       ``Pbox``



.. py:function:: mean_var(mean: Union[PyUncertainNumber.pba.logical.Interval, float, int], var: Union[PyUncertainNumber.pba.logical.Interval, float, int], steps=Pbox.STEPS) -> PyUncertainNumber.pba.logical.Pbox

   Generates a distribution-free p-box based upon the mean and variance of the variable

   Equivalent to `mean_std(mean,np.sqrt(var))`

   **Parameters**:

       ``mean`` : mean of the variable

       ``var`` : variance of the variable


   **Returns**:

       ``Pbox``



.. py:function:: pos_mean_std(mean: Union[PyUncertainNumber.pba.logical.Interval, float, int], std: Union[PyUncertainNumber.pba.logical.Interval, float, int], steps=Pbox.STEPS) -> PyUncertainNumber.pba.logical.Pbox

   Generates a positive distribution-free p-box based upon the mean and standard deviation of the variable

   **Parameters**:

       ``mean`` : mean of the variable

       ``std`` : standard deviation of the variable


   **Returns**:

       ``Pbox``



.. py:function:: symmetric_mean_std(mean: Union[PyUncertainNumber.pba.logical.Interval, float, int], std: Union[PyUncertainNumber.pba.logical.Interval, float, int], steps: int = Pbox.STEPS) -> PyUncertainNumber.pba.logical.Pbox

   Generates a symmetrix distribution-free p-box based upon the mean and standard deviation of the variable

   **Parameters**:

   ``mean`` :  mean value of the variable
   ``std`` : standard deviation of the variable

   **Returns**

       ``Pbox``



.. py:function:: from_percentiles(percentiles: dict, steps: int = Pbox.STEPS) -> PyUncertainNumber.pba.logical.Pbox

   Generates a distribution-free p-box based upon percentiles of the variable

   **Parameters**

       ``percentiles`` : dictionary of percentiles and their values (e.g. {0: 0, 0.1: 1, 0.5: 2, 0.9: Interval(3,4), 1:5})

       ``steps`` : number of steps to use in the p-box

   .. important::

       The percentiles dictionary is of the form {percentile: value}. Where value can either be a number or an Interval. If value is a number, the percentile is assumed to be a point percentile. If value is an Interval, the percentile is assumed to be an interval percentile.

   .. warning::

       If no keys for 0 and 1 are given, ``-np.inf`` and ``np.inf`` are used respectively. This will result in a p-box that is not bounded and raise a warning.

       If the percentiles are not increasing, the percentiles will be intersected. This may not be desired behaviour.

   .. error::

       ``ValueError``: If any of the percentiles are not between 0 and 1.

   **Returns**

       ``Pbox``


   **Example**:

   .. code-block:: python

       pba.from_percentiles(
           {0: 0,
           0.25: 0.5,
           0.5: pba.I(1,2),
           0.75: pba.I(1.5,2.5),
           1: 3}
       ).show()

   .. image:: https://github.com/Institute-for-Risk-and-Uncertainty/pba-for-python/blob/master/docs/images/from_percentiles.png?raw=true
       :scale: 35 %
       :align: center
       :alt: Pbox generated from percentiles



