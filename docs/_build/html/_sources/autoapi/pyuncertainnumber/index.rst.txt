pyuncertainnumber
=================

.. py:module:: pyuncertainnumber


Submodules
----------

.. toctree::
   :maxdepth: 1

   /autoapi/pyuncertainnumber/UV/index
   /autoapi/pyuncertainnumber/characterisation/index
   /autoapi/pyuncertainnumber/nlp/index
   /autoapi/pyuncertainnumber/pba/index
   /autoapi/pyuncertainnumber/propagation/index


Attributes
----------

.. autoapisummary::

   pyuncertainnumber.named_pbox
   pyuncertainnumber.named_dists


Classes
-------

.. autoapisummary::

   pyuncertainnumber.Uncertainty_types
   pyuncertainnumber.Ensemble
   pyuncertainnumber.nInterval
   pyuncertainnumber.Params
   pyuncertainnumber.DistributionSpecification
   pyuncertainnumber.Distribution
   pyuncertainnumber.UncertainNumber
   pyuncertainnumber.EnhancedJSONEncoder
   pyuncertainnumber.PBAEncoder
   pyuncertainnumber.UNEncoder
   pyuncertainnumber.dempstershafer_element
   pyuncertainnumber.DempsterShafer


Functions
---------

.. autoapisummary::

   pyuncertainnumber.hedge_interpret
   pyuncertainnumber.convert
   pyuncertainnumber.parse_bounds
   pyuncertainnumber.makeUNPbox
   pyuncertainnumber.I
   pyuncertainnumber.norm
   pyuncertainnumber.expon
   pyuncertainnumber.gamma
   pyuncertainnumber._parse_interverl_inputs
   pyuncertainnumber.tranform_ecdf
   pyuncertainnumber.pl_pcdf
   pyuncertainnumber.pl_ecdf
   pyuncertainnumber.to_database
   pyuncertainnumber.cd_root_dir
   pyuncertainnumber.initial_list_checking
   pyuncertainnumber.bad_list_checking
   pyuncertainnumber.PlusMinus_parser
   pyuncertainnumber.parser4
   pyuncertainnumber.percentage_finder
   pyuncertainnumber.percentage_converter
   pyuncertainnumber.get_concise_repr
   pyuncertainnumber.array2list
   pyuncertainnumber.entries_to_remove
   pyuncertainnumber.known_constraints
   pyuncertainnumber.min_max
   pyuncertainnumber.min_max_mean
   pyuncertainnumber.min_mean
   pyuncertainnumber.min_max_mean_std
   pyuncertainnumber.min_max_mean_var
   pyuncertainnumber.min_max_mode
   pyuncertainnumber.min_max_median
   pyuncertainnumber.min_max_median_is_mode
   pyuncertainnumber.mean_std
   pyuncertainnumber.mean_var
   pyuncertainnumber.pos_mean_std
   pyuncertainnumber.symmetric_mean_std
   pyuncertainnumber.from_percentiles
   pyuncertainnumber.KS_bounds
   pyuncertainnumber.fit
   pyuncertainnumber.stochastic_mixture
   pyuncertainnumber.envelope
   pyuncertainnumber.imposition
   pyuncertainnumber.stacking
   pyuncertainnumber.hedge_interpret
   pyuncertainnumber.infer_cbox
   pyuncertainnumber.infer_predictive_distribution


Package Contents
----------------

.. py:class:: Uncertainty_types(*args, **kwds)

   Bases: :py:obj:`enum.Enum`


   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access::

   >>> Color.RED
   <Color.RED: 1>

   - value lookup:

   >>> Color(1)
   <Color.RED: 1>

   - name lookup:

   >>> Color['RED']
   <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.


   .. py:attribute:: Certain
      :value: 'certain'



   .. py:attribute:: Aleatory
      :value: 'aleatory'



   .. py:attribute:: Epistemic
      :value: 'epistemic'



   .. py:attribute:: Inferential
      :value: 'inferential'



   .. py:attribute:: Design_uncertainty
      :value: 'design uncertainty'



   .. py:attribute:: Vagueness
      :value: 'vagueness'



   .. py:attribute:: Mixture
      :value: 'mixture'



.. py:class:: Ensemble(*args, **kwds)

   Bases: :py:obj:`enum.Enum`


   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access::

   >>> Color.RED
   <Color.RED: 1>

   - value lookup:

   >>> Color(1)
   <Color.RED: 1>

   - name lookup:

   >>> Color['RED']
   <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.


   .. py:attribute:: repeated_measurements
      :value: 'repeated measurements'



   .. py:attribute:: flights
      :value: 'flights'



   .. py:attribute:: pressurisations
      :value: 'pressurisations'



   .. py:attribute:: temporal_steps
      :value: 'temporal steps'



   .. py:attribute:: spatial_sites
      :value: 'spatial sites'



   .. py:attribute:: manufactured_components
      :value: 'manufactured components'



   .. py:attribute:: customers
      :value: 'customers'



   .. py:attribute:: people
      :value: 'people'



   .. py:attribute:: households
      :value: 'households'



   .. py:attribute:: particular_population
      :value: 'particular population'



.. py:class:: nInterval(left=None, right=None)

   An interval is an uncertain number for which only the endpoints are known, :math:`x=[a,b]`.
   This is interpreted as :math:`x` being between :math:`a` and :math:`b` but with no more information about the value of :math:`x`.

   Intervals embody epistemic uncertainty within PBA.

   Creation
   ________

   Intervals can be created using either of the following:

   .. code-block:: python

       >>> pba.Interval(0,1)
       Interval [0,1]
       >>> pba.I(2,3)
       Interval [2,3]

   .. tip::

       The shorthand ``I`` is an alias for ``Interval``

   Intervals can also be created from a single value Â± half-width:

   >>> pba.PM(0,1)
   Interval [-1,1]

   By default intervals are displayed as ``Interval [a,b]`` where ``a`` and ``b`` are the left and right endpoints respectively. This can be changed using the `interval.pm_repr`_ and `interval.lr_repr`_ functions.

   Arithmetic
   __________

   For two intervals [a,b] and [c,d] the following arithmetic operations are defined:

   **Addition**

   :math:`[a,b] + [c,d] = [a+c,b+d]`

   **Subtraction**

   :math:`[a,b] - [c,d] = [a-d,b-c]`

   **Multiplication**

   :math:`[a,b] * [c,d] = [\min(ac,ad,bc,bd),\max(ac,ad,bc,bd)]`

   **Division**

   :math:`[a,b] / [c,d] = [a,b] * \frac{1}{[c,d]} \equiv [\min(a/c,a/d,b/c,b/d),\max(a/c,a/d,b/c,b/d)]`

   Alternative arithmetic methods are described in `interval.add`_, `interval.sub`_, `interval.mul`_, `interval.div`_.



   .. py:attribute:: _left
      :value: None



   .. py:attribute:: _right
      :value: None



   .. py:property:: left


   .. py:property:: right


   .. py:method:: __repr__() -> str


   .. py:method:: __str__() -> str


   .. py:method:: __format__(format_spec: str) -> str


   .. py:method:: __iter__()


   .. py:method:: __len__()


   .. py:method:: __radd__(left)


   .. py:method:: __sub__(other)


   .. py:method:: __rsub__(other)


   .. py:method:: __neg__()


   .. py:method:: __mul__(other)


   .. py:method:: __rmul__(other)


   .. py:method:: __truediv__(other)


   .. py:method:: __rtruediv__(other)


   .. py:method:: __pow__(other)


   .. py:method:: __rpow__(left)


   .. py:method:: __lt__(other)


   .. py:method:: __rgt__(other)


   .. py:method:: __eq__(other)

      ==



   .. py:method:: __gt__(other)

      >



   .. py:method:: __rlt__(other)


   .. py:method:: __ne__(other)

      !=



   .. py:method:: __le__(other)

      <=



   .. py:method:: __ge__(other)


   .. py:method:: __bool__()


   .. py:method:: __abs__()


   .. py:method:: __contains__(other)


   .. py:method:: add(other, method=None)

      .. _interval.add:

      Adds the interval and another object together.


      **Args**:

          ``other``: The interval or numeric value to be added. This value must be transformable into an Interval object.

      **Methods**:

          p - perfect arithmetic :math:`[a,b]+[c,d] = [a + c, b + d]`

          o - opposite arithmetic :math:`[a,b]+[c,d] = [a + d, b + c]`

          None, i, f - Standard interval arithmetic is used.

      **Returns**:

          ``Interval``




   .. py:method:: __add__(other)


   .. py:method:: padd(other)

      .. warning::
          This method is deprecated. Use add(other, method='p') instead.



   .. py:method:: oadd(other)

      .. warning::
          This method is deprecated. Use add(other, method='o') instead.



   .. py:method:: sub(other, method=None)

      .. _interval.sub:

      Subtracts other from self.

      **Args**:

          ``other``: The interval or numeric value to be subracted. This value must be transformable into an Interval object.

      **Methods**:

          ``p``: perfect arithmetic :math:`a+b = [a.left - b.left, a.right - b.right]`

          ``o``: opposite arithmetic :math:`a+b = [a.left - b.right, a.right - b.left]`

          None, i, f - Standard interval arithmetic is used.

      **Returns**:

          ``Interval``




   .. py:method:: psub(other)

      .. warning::
          Depreciated use self.sub(other, method = 'p') instead



   .. py:method:: osub(other)

      .. warning::
          Depreciated use self.sub(other, method = 'o') instead



   .. py:method:: mul(other, method=None)

      .. _interval.mul:

      Multiplies self by other.

      **Args**:

          ``other``: The interval or numeric value to be multiplied. This value must be transformable into an Interval object.


      **Methods**:
          ``p``: perfect arithmetic :math:`[a,b],[c,d] = [a * c, b * d]`

          ``o``: opposite arithmetic :math:`[a,b],[c,d] = [a * d, b * c]`

          None, i, f - Standard interval arithmetic is used.

      **Returns**:
          Interval: The result of the multiplication.





   .. py:method:: pmul(other)

      .. warning::
          Depreciated use self.mul(other, method = 'p') instead



   .. py:method:: omul(other)

      .. warning::
          Depreciated use self.mul(other, method = 'o') instead



   .. py:method:: div(other, method=None)

      .. _interval.div:

      Divides self by other


      If :math:`0 \in other` it returns a division by zero error


      **Args**:

          ``other`` (Interval or numeric): The interval or numeric value to be multiplied. This value must be transformable into an Interval object.

      **Methods**:

          ``p``: perfect arithmetic :math:`[a,b],[c,d] = [a * 1/c, b * 1/d]`

          ``o``: opposite arithmetic :math:`[a,b],[c,d] = [a * 1/d, b * 1/c]`

          ``None``, ``i``, ``f`` - Standard interval arithmetic is used.

      .. admonition:: Implementation

          >>> self.add(1/other, method = method)

      .. error::

          If :math:`0 \in [a,b]` it returns a division by zero error




   .. py:method:: pdiv(other)

      .. warning::
          Depreciated use self.div(other, method = 'p') instead



   .. py:method:: odiv(other)

      .. warning::
          Depreciated use self.div(other, method = 'o') instead




   .. py:method:: recip()

      Calculates the reciprocle of the interval.

      **Returns**:

          ``Interval``: Equal to :math:`[1/b,1/a]`

      **Example**:

          >>> pba.Interval(2,4).recip()
          Interval [0.25, 0.5]

      .. error::
          If :math:`0 \in [a,b]` it returns a division by zero error




   .. py:method:: equiv(other: Interval) -> bool

      Checks whether two intervals are equivalent.

      **Parameters**:

          ``other``: The interval to check against.

      **Returns** ``True`` **if**:

          ``self.left == other.right`` and ``self.right == other.right``

          ``False`` otherwise.

      .. error::

          ``TypeError``: If ``other`` is not an instance of ``Interval``

      .. seealso::
          :func:`~logical.is_same_as`

      **Examples**:

          >>> a = Interval(0,1)
          >>> b = Interval(0.5,1.5)
          >>> c = I(0,1)
          >>> a.equiv(b)
          False
          >>> a.equiv(c)
          True




   .. py:property:: lo

      



      **Returns**:
          ``self.left``

      .. tip::

          This function is redundant but exists to match Pbox class for possible internal reasons.


   .. py:property:: hi

      



      **Returns**:
          ``self.right``

      .. tip::

          This function is redundant but exists to match Pbox class for possible internal reasons.


   .. py:method:: width() -> float

      **Returns**:

          ``float``: The width of the interval, :math:`\mathrm{right} - \mathrm{left}`

      **Example**:

          >>> pba.Interval(0,3).width()
          3




   .. py:method:: halfwidth() -> float

      **Returns**:

          ``float``: The half-width of the interval, :math:`(\mathrm{right} - \mathrm{left})/2`

      **Example**:

          >>> pba.Interval(0,3).halfwidth()
          1.5

      .. admonition:: Implementation

          >>> self.width()/2




   .. py:method:: midpoint() -> float

      Returns the midpoint of the interval

      .. note:: - this serves as the deterministic value representation of the interval, a.k.a. the naked value for an interval

      :returns: The midpoint of the interval, :math:`(\mathrm{right} + \mathrm{left})/2`
      :rtype: ``float``

      **Example**:
              >>> pba.Interval(0,2).midpoint()
              1.0



   .. py:method:: to_logical()

      Turns the interval into a logical interval, this is done by chacking the truth value of the ends of the interval

      **Returns**:

          ``Logical``: The logical interval

      .. admonition:: Implementation

          >>> left = self.left.__bool__()
          >>> right = self.right.__bool__()
          >>> Logical(left,right)





   .. py:method:: env(other: Union[list, Interval]) -> Interval

      Calculates the envelope between two intervals

      **Parameters**:

          ``other`` : Interval or list. The interval to envelope with self

      .. hint::

          If other is a list then the envelope is calculated between self and each element of the list. In this case the envelope is calculated recursively and pba.envelope() may be more efficient.

      .. important::
          If other is a Pbox then ``Pbox.env()`` is called

      .. seealso::

          `pba.core.envelope`_

          `pba.pbox.Pbox.env`_

      **Returns**:

          ``Interval``: The envelope of self and other





   .. py:method:: straddles(N: Union[int, float, Interval], endpoints: bool = True) -> bool

      .. _interval.straddles:

      **Parameters**:

          ``N``: Number to check. If N is an interval checks whether the whole interval is within self.

          ``endpoints``: Whether to include the endpoints within the check

      **Returns** ``True`` **if**:

          :math:`\mathrm{left} \leq N \leq \mathrm{right}` (Assuming ``endpoints=True``).

          For interval values. :math:`\mathrm{left} \leq N.left \leq \mathrm{right}` and :math:`\mathrm{left} \leq N.right \leq \mathrm{right}` (Assuming ``endpoints=True``).

          ``False`` otherwise.

      .. tip::

          ``N in self`` is equivalent to ``self.straddles(N)``




   .. py:method:: straddles_zero(endpoints=True)

      Checks whether :math:`0` is within the interval

      .. admonition:: Implementation

          Equivalent to ``self.straddles(0,endpoints)``

      .. seealso::
          interval.straddles_




   .. py:method:: intersection(other: Union[Interval, list]) -> Interval

      Calculates the intersection between intervals

      **Parameters**:

          ``other``: The interval to intersect with self. If an interval is not given will try to cast as an interval. If a list is given will calculate the intersection between self and each element of the list.

      **Returns**:

          ``Interval``: The intersection of self and other. If no intersection is found returns ``None``

      **Example**:

          >>> a = Interval(0,1)
          >>> b = Interval(0.5,1.5)
          >>> a.intersection(b)
          Interval [0.5, 1]



   .. py:method:: exp()


   .. py:method:: log()


   .. py:method:: sqrt()


   .. py:method:: display(title='', ax=None, style='band', **kwargs)


   .. py:method:: sample(seed=None, numpy_rng: numpy.random.Generator = None) -> float

      Generate a random sample within the interval.

      **Parameters**:

          ``seed`` (int, optional): Seed value for random number generation. Defaults to None.

          ``numpy_rng`` (numpy.random.Generator, optional): Numpy random number generator. Defaults to None.

      **Returns**:

          ``float``: Random sample within the interval.

      .. admonition:: Implementation

          If ``numpy_rng`` is given:

              >>> numpy_rng.uniform(self.left, self.right)

          Otherwise the following is used:

          >>> import random
          >>> random.seed(seed)
          >>> self.left + random.random() * self.width()

      **Examples**:

          >>> pba.Interval(0,1).sample()
          0.6160988752201705
          >>> pba.I(0,1).sample(seed = 1)
          0.13436424411240122

      If a numpy random number generator is given then it is used instead of the default python random number generator. It has to be initialised first.

          >>> import numpy as np
          >>> rng = np.random.default_rng(seed = 0)
          >>> pba.I(0,1).sample(numpy_rng = rng)
          0.6369616873214543



   .. py:method:: round()

      outward rounding operation for an interval object



   .. py:method:: from_midwith(midpoint: float, halfwidth: float) -> Interval
      :classmethod:


      Creates an Interval object from a midpoint and half-width.

      :param - midpoint: The midpoint of the interval.
      :type - midpoint: float
      :param - halfwidth: The half-width of the interval.
      :type - halfwidth: float

      :returns: The interval with midpoint and half-width.
      :rtype: - Interval

      .. rubric:: Example

      >>> pba.Interval.from_midwith(0,1)
      Interval [-1, 1]



.. py:class:: Params

   .. py:attribute:: hedge_cofficients


   .. py:attribute:: steps
      :value: 200



   .. py:attribute:: many
      :value: 2000



   .. py:attribute:: p_values


   .. py:attribute:: p_lboundary
      :value: 0.0001



   .. py:attribute:: p_hboundary
      :value: 0.9999



   .. py:attribute:: scott_hedged_interpretation


   .. py:attribute:: user_hedged_interpretation


   .. py:attribute:: result_path
      :value: './results/'



   .. py:attribute:: hw
      :value: 0.5



.. py:function:: hedge_interpret(hedge: str, return_type='interval') -> pyuncertainnumber.pba.interval.Interval | pyuncertainnumber.pba.pbox_base.Pbox

   interpret linguistic hedge words into UncertainNumber objects

   :param hedge: the hedge numerical expression to be interpreted
   :type hedge: str
   :param return_type: the type of object to be returned, either 'interval' or 'pbox'
   :type return_type: str

   .. note:: - the return can either be an interval or a pbox object

   .. rubric:: Example

   >>> hedge_interpret("about 200", return_type="pbox")


.. py:class:: DistributionSpecification(dist_family: str, dist_params: tuple)

   an attempt to double check the user specification for a pbox or dist

   .. note:: - canonical form: ['gaussian', ([0,1], [1,2])]

   # TODO: unfinished logic


   .. py:attribute:: dist_family


   .. py:attribute:: dist_params


   .. py:method:: tell_i_flag()

      boolean about if imprecise specification



   .. py:property:: i_flag


   .. py:method:: get_specification()


.. py:data:: named_pbox

.. py:class:: Distribution

   two signature for the distribution object, either a parametric specification or a nonparametric sample per se


   .. py:attribute:: dist_family
      :type:  str
      :value: None



   .. py:attribute:: dist_params
      :type:  list[float] | Tuple[float, Ellipsis]
      :value: None



   .. py:attribute:: sample_data
      :type:  list[float] | numpy.ndarray
      :value: None



   .. py:method:: __post_init__()


   .. py:method:: __repr__()


   .. py:method:: rep()

      the dist object either sps dist or sample approximated or pbox dist



   .. py:method:: flag()

      boolean flag for if the distribution is a parameterised distribution or not
      .. note::

         - only parameterised dist can do sampling
         - for non-parameterised sample-data based dist, next steps could be fitting



   .. py:method:: sample(size)

      generate deviates from the distribution



   .. py:method:: make_naked_value()

      one value representation of the distribution
      .. note:: - use mean for now;



   .. py:method:: display(**kwargs)

      display the distribution



   .. py:method:: _get_hint()


   .. py:method:: fit(data)

      fit the distribution to the data



   .. py:property:: naked_value


   .. py:property:: hint


   .. py:method:: dist_from_sps(dist: scipy.stats.rv_continuous | scipy.stats.rv_discrete, shape: str = None)
      :classmethod:



   .. py:method:: to_pbox()

      convert the distribution to a pbox
      .. note::

         - this only works for parameteried distributions for now
         - later on work with sample-approximated dist until `fit()`is implemented



.. py:data:: named_dists

.. py:function:: convert(un)

   transform the input un into a Pbox object

   .. note:: - theorically 'un' can be {Interval, DempsterShafer, Distribution, float, int}


.. py:function:: parse_bounds(bounds)

   parse the self.bounds argument


.. py:class:: UncertainNumber

   Uncertain Number class

   :param - `bounds`;:
   :param - `distribution_parameters`: a list of the distribution family and its parameters; e.g. ['norm', [0, 1]];
   :param - `pbox_initialisation`: a list of the distribution family and its parameters; e.g. ['norm', ([0,1], [3,4])];
   :param -  naked_value: the deterministic numeric representation of the UN object, which shall be linked with the 'pba' or `Intervals` package

   .. rubric:: Example

   >>> UncertainNumber(name="velocity", symbol="v", units="m/s", bounds=[1, 2])


   .. py:attribute:: name
      :type:  str
      :value: None



   .. py:attribute:: symbol
      :type:  str
      :value: None



   .. py:attribute:: units
      :type:  Type[any]
      :value: None



   .. py:attribute:: _Q
      :type:  Type[any]
      :value: None



   .. py:attribute:: uncertainty_type
      :type:  Type[pyuncertainnumber.characterisation.uncertainty_types.Uncertainty_types]
      :value: None



   .. py:attribute:: essence
      :type:  str
      :value: None



   .. py:attribute:: masses
      :type:  list[float]
      :value: None



   .. py:attribute:: bounds
      :type:  Union[List[float], str]
      :value: None



   .. py:attribute:: distribution_parameters
      :type:  list[str, float | int]
      :value: None



   .. py:attribute:: pbox_parameters
      :type:  list[str, Sequence[pyuncertainnumber.pba.interval.Interval]]
      :value: None



   .. py:attribute:: hedge
      :type:  str
      :value: None



   .. py:attribute:: _construct
      :type:  Type[any]
      :value: None



   .. py:attribute:: naked_value
      :type:  float
      :value: None



   .. py:attribute:: p_flag
      :type:  bool
      :value: True



   .. py:attribute:: measurand
      :type:  str
      :value: None



   .. py:attribute:: nature
      :type:  str
      :value: None



   .. py:attribute:: provenence
      :type:  str
      :value: None



   .. py:attribute:: justification
      :type:  str
      :value: None



   .. py:attribute:: structure
      :type:  str
      :value: None



   .. py:attribute:: security
      :type:  str
      :value: None



   .. py:attribute:: ensemble
      :type:  Type[pyuncertainnumber.characterisation.ensemble.Ensemble]
      :value: None



   .. py:attribute:: variability
      :type:  str
      :value: None



   .. py:attribute:: dependence
      :type:  str
      :value: None



   .. py:attribute:: uncertainty
      :type:  str
      :value: None



   .. py:attribute:: instances
      :value: []



   .. py:attribute:: _samples
      :type:  pyuncertainnumber.characterisation.utils.np.ndarray | list
      :value: None



   .. py:method:: parameterised_pbox_specification()


   .. py:method:: __post_init__()

      the de facto initialisation method for the core math objects of the UN class

      caveat:
          user needs to by themselves figure out the correct
          shape of the 'distribution_parameters', such as ['uniform', [1,2]]



   .. py:method:: match_pbox(keyword, parameters)
      :staticmethod:


      match the distribution keyword from the initialisation to create the underlying distribution object

      :param - keyword: (str) the distribution keyword
      :param - parameters: (list) the parameters of the distribution



   .. py:method:: init_check()

      check if the UN initialisation specification is correct

      .. note::

         a lot of things to double check. keep an growing list:
         1. unit
         2. hedge: user cannot speficy both 'hedge' and 'bounds'. 'bounds' takes precedence.



   .. py:method:: __str__()

      the verbose user-friendly string representation
      .. note::

         this has nothing to do with the logic of JSON serialisation
         ergo, do whatever you fancy;



   .. py:method:: __repr__() -> str

      concise __repr__



   .. py:method:: describe(type='verbose')

      print out a verbose description of the uncertain number



   .. py:method:: _get_concise_representation()

      get a concise representation of the UN object



   .. py:method:: ci()

      get 95% range confidence interval



   .. py:method:: display(**kwargs)

      quick plot of the uncertain number object



   .. py:property:: construct


   .. py:method:: from_hedge(hedged_language)
      :classmethod:


      create an Uncertain Number from hedged language

      .. note::

         # if interval or pbox, to be implemented later on
         #  currently only Interval is supported



   .. py:method:: fromConstruct(construct)
      :classmethod:


      create an Uncertain Number from a construct object



   .. py:method:: fromDistribution(D, **kwargs)
      :classmethod:


      create an Uncertain Number from specification of distribution

      :param - D: Distribution object
      :param dist_family: the distribution family
      :type dist_family: str
      :param dist_params: the distribution parameters
      :type dist_params: list, tuple or string



   .. py:method:: from_Interval(u)
      :classmethod:



   .. py:method:: from_pbox(p)
      :classmethod:


      genenal from  pbox



   .. py:method:: from_ds(ds)
      :classmethod:



   .. py:method:: from_sps(sps_dist)
      :classmethod:


      create an UN object from a parametric scipy.stats dist object
      #! it seems that a function will suffice
      :param - sps_dist: scipy.stats dist object

      .. note:: - sps_dist --> UN.Distribution object



   .. py:method:: sqrt()


   .. py:method:: __add__(other)

      add two uncertain numbers



   .. py:method:: __radd__(other)


   .. py:method:: __sub__(other)


   .. py:method:: __mul__(other)

      multiply two uncertain numbers



   .. py:method:: __rmul__(other)


   .. py:method:: __truediv__(other)

      divide two uncertain numbers



   .. py:method:: __rtruediv__(other)


   .. py:method:: __pow__(other)

      power of two uncertain numbers



   .. py:method:: _toIntervalBackend(vars=None) -> pyuncertainnumber.characterisation.utils.np.array
      :classmethod:


      transform any UN object to an `interval`
      #! currently in use
      # TODO think if use Marco's Interval Vector object

      question:
          - what is the `interval` representation: list, nd.array or Interval object?

      :returns:

                - 2D np.array representation for all the interval-typed UNs



   .. py:method:: _IntervaltoCompBackend(vars)
      :classmethod:


      convert the interval-tupe UNs instantiated to the computational backend

      .. note::

         - it will automatically convert all the UN objects in array-like to the computational backend
         - essentially vars shall be all interval-typed UNs by now

      :returns:

                - nd.array or Marco's Interval object

      thoughts:
          - if Marco's, then we'd use `intervalise` func to get all interval objects
          and then to create another func to convert the interval objects to np.array to do endpoints method



   .. py:method:: JSON_dump(filename='UN_data.json')

      the JSON serialisation of the UN object into the filesystem



   .. py:method:: random(size=None)

      Generate random samples from the distribution.



   .. py:method:: ppf(q=None)

      "Calculate the percent point function (inverse of CDF) at quantile q.



.. py:function:: makeUNPbox(func)

.. py:function:: I(i: str | list[float | int]) -> UncertainNumber

   a shortcut for the interval-type UN object


.. py:function:: norm(*args)

.. py:function:: expon(*args)

.. py:function:: gamma(*args)

.. py:function:: _parse_interverl_inputs(vars)

   Parse the input intervals

   .. note:: - Ioanna's funcs typically take 2D NumPy arra


.. py:function:: tranform_ecdf(s, display=False, **kwargs)

   plot the CDF return the quantile

   :param s: sample


.. py:function:: pl_pcdf(dist: type[scipy.stats.rv_continuous | scipy.stats.rv_discrete], ax=None, title=None, **kwargs)

   plot CDF from parametric distribution objects


.. py:function:: pl_ecdf(s, ax=None, return_value=False, **kwargs)

   plot the empirical CDF given samples

   :param s: sample which can be either raw data
             or deviates as a representation of dist construct
   :type s: array-like


.. py:function:: to_database(dict_list, db_name, col_name)

.. py:function:: cd_root_dir(depth=0)

.. py:function:: initial_list_checking(text)

   detects if a string representation of a list


.. py:function:: bad_list_checking(text)

   detects if a syntactically wrong specification of a list


.. py:function:: PlusMinus_parser(txt)

.. py:function:: parser4(text)

.. py:function:: percentage_finder(txt)

.. py:function:: percentage_converter(txt)

   convert a percentage into a float number

   .. note:: force only 1 percentage


.. py:class:: EnhancedJSONEncoder(*, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, sort_keys=False, indent=None, separators=None, default=None)

   Bases: :py:obj:`json.JSONEncoder`


   a template for jsonify general (dataclass) object

   #TODO Interval object in not json serializable


   .. py:method:: default(o)

      Implement this method in a subclass such that it returns
      a serializable object for ``o``, or calls the base implementation
      (to raise a ``TypeError``).

      For example, to support arbitrary iterators, you could
      implement default like this::

          def default(self, o):
              try:
                  iterable = iter(o)
              except TypeError:
                  pass
              else:
                  return list(iterable)
              # Let the base class default method raise the TypeError
              return super().default(o)




.. py:class:: PBAEncoder(*, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, sort_keys=False, indent=None, separators=None, default=None)

   Bases: :py:obj:`json.JSONEncoder`


   a bespoke JSON encoder for the PBA object


   .. py:method:: default(o)

      Implement this method in a subclass such that it returns
      a serializable object for ``o``, or calls the base implementation
      (to raise a ``TypeError``).

      For example, to support arbitrary iterators, you could
      implement default like this::

          def default(self, o):
              try:
                  iterable = iter(o)
              except TypeError:
                  pass
              else:
                  return list(iterable)
              # Let the base class default method raise the TypeError
              return super().default(o)




.. py:class:: UNEncoder(*, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, sort_keys=False, indent=None, separators=None, default=None)

   Bases: :py:obj:`json.JSONEncoder`


   a bespoke JSON encoder for the UncertainNumber object

   .. note::

      - Currently I'm treating the JSON data represent of a UN object
      the same as the __repr__ method. But this can be changed later on to
      show more explicitly the strucutre of pbox or distribution
      # TODO prettify the JSON output to be explicit
      e.g. 'essence': 'interval', 'interval_initialisation': [2, 3] to shown as 'interval' with lower end and upper end
      distribution to shown as the type and parameters; e.g. 'distribution': 'normal', 'parameters': [2, 3]


   .. py:method:: default(o)

      Implement this method in a subclass such that it returns
      a serializable object for ``o``, or calls the base implementation
      (to raise a ``TypeError``).

      For example, to support arbitrary iterators, you could
      implement default like this::

          def default(self, o):
              try:
                  iterable = iter(o)
              except TypeError:
                  pass
              else:
                  return list(iterable)
              # Let the base class default method raise the TypeError
              return super().default(o)




.. py:function:: get_concise_repr(a_dict)

.. py:function:: array2list(a_dict)

   convert an array from a dictionary into a list


.. py:function:: entries_to_remove(remove_entries, the_dict)

.. py:function:: known_constraints(minimum: Optional[Union[pyuncertainnumber.pba.interval.Interval, float, int]] = None, maximum: Optional[Union[pyuncertainnumber.pba.interval.Interval, float, int]] = None, mean: Optional[Union[pyuncertainnumber.pba.interval.Interval, float, int]] = None, median: Optional[Union[pyuncertainnumber.pba.interval.Interval, float, int]] = None, mode: Optional[Union[pyuncertainnumber.pba.interval.Interval, float, int]] = None, std: Optional[Union[pyuncertainnumber.pba.interval.Interval, float, int]] = None, var: Optional[Union[pyuncertainnumber.pba.interval.Interval, float, int]] = None, cv: Optional[Union[pyuncertainnumber.pba.interval.Interval, float, int]] = None, percentiles: Optional[dict[Union[pyuncertainnumber.pba.interval.Interval, float, int]]] = None, debug: bool = False, steps: int = Params.steps) -> pyuncertainnumber.pba.pbox_base.Pbox

   Generates a distribution free p-box based upon the information given.
   This function works by calculating every possible non-parametric p-box that can be generated using the information provided.
   The returned p-box is the intersection of these p-boxes.

   **Parameters**:

       ``minimum``: Minimum value of the variable
       ``maximum``: Maximum value of the variable
       ``mean``: Mean value of the variable
       ``median``: Median value of the variable
       ``mode``: Mode value of the variable
       ``std``: Standard deviation of the variable
       ``var``: Variance of the variable
       ``cv``: Coefficient of variation of the variable
       ``percentiles``: Dictionary of percentiles and their values (e.g. {0.1: 1, 0.5: 2, 0.9: nInterval(3,4)})
       ``steps``: Number of steps to use in the p-box

   .. error::

       ``ValueError``: If any of the arguments are not consistent with each other. (i.e. if ``std`` and ``var`` are both given, but ``std != sqrt(var)``)

   **Returns**:

       ``Pbox``: Imposition of possible p-boxes


.. py:function:: min_max(a: Union[pyuncertainnumber.pba.interval.Interval, float, int], b: Union[pyuncertainnumber.pba.interval.Interval, float, int] = None, steps=Params.steps, shape='box') -> pyuncertainnumber.pba.pbox_base.Pbox

   Returns a box shaped Pbox. This is equivalent to an nInterval expressed as a Pbox.

   **Parameters**:

       ``a`` : Left side of box
       ``b``: Right side of box


   **Returns**:

       ``Pbox``



.. py:function:: min_max_mean(minimum: Union[pyuncertainnumber.pba.interval.Interval, float, int], maximum: Union[pyuncertainnumber.pba.interval.Interval, float, int], mean: Union[pyuncertainnumber.pba.interval.Interval, float, int], steps: int = Params.steps) -> pyuncertainnumber.pba.pbox_base.Pbox

   Generates a distribution-free p-box based upon the minimum, maximum and mean of the variable

   **Parameters**:

       ``minimum`` : minimum value of the variable

       ``maximum`` : maximum value of the variable

       ``mean`` : mean value of the variable


   **Returns**:

       ``Pbox``


.. py:function:: min_mean(minimum: Union[pyuncertainnumber.pba.interval.Interval, float, int], mean: Union[pyuncertainnumber.pba.interval.Interval, float, int], steps=Params.steps) -> pyuncertainnumber.pba.pbox_base.Pbox

   Generates a distribution-free p-box based upon the minimum and mean of the variable

   **Parameters**:

       ``minimum`` : minimum value of the variable

       ``mean`` : mean value of the variable


   **Returns**:

       ``Pbox``


.. py:function:: min_max_mean_std(minimum: Union[pyuncertainnumber.pba.interval.Interval, float, int], maximum: Union[pyuncertainnumber.pba.interval.Interval, float, int], mean: Union[pyuncertainnumber.pba.interval.Interval, float, int], std: Union[pyuncertainnumber.pba.interval.Interval, float, int], steps: int = Params.steps) -> pyuncertainnumber.pba.pbox_base.Pbox

   Generates a distribution-free p-box based upon the minimum, maximum, mean and standard deviation of the variable

   **Parameters**

       ``minimum`` : minimum value of the variable
       ``maximum`` : maximum value of the variable
       ``mean`` : mean value of the variable
       ``std`` :standard deviation of the variable

   **Returns**

       ``Pbox``

   .. seealso::

       :func:`min_max_mean_var`



.. py:function:: min_max_mean_var(minimum: Union[pyuncertainnumber.pba.interval.Interval, float, int], maximum: Union[pyuncertainnumber.pba.interval.Interval, float, int], mean: Union[pyuncertainnumber.pba.interval.Interval, float, int], var: Union[pyuncertainnumber.pba.interval.Interval, float, int], steps: int = Params.steps) -> pyuncertainnumber.pba.pbox_base.Pbox

   Generates a distribution-free p-box based upon the minimum, maximum, mean and standard deviation of the variable

   **Parameters**

       ``minimum`` : minimum value of the variable
       ``maximum`` : maximum value of the variable
       ``mean`` : mean value of the variable
       ``var`` :variance of the variable

   **Returns**

       ``Pbox``


   .. admonition:: Implementation

       Equivalent to ``min_max_mean_std(minimum,maximum,mean,np.sqrt(var))``

   .. seealso::

       :func:`min_max_mean_std`



.. py:function:: min_max_mode(minimum: Union[pyuncertainnumber.pba.interval.Interval, float, int], maximum: Union[pyuncertainnumber.pba.interval.Interval, float, int], mode: Union[pyuncertainnumber.pba.interval.Interval, float, int], steps: int = Params.steps) -> pyuncertainnumber.pba.pbox_base.Pbox

   Generates a distribution-free p-box based upon the minimum, maximum, and mode of the variable

   **Parameters**:

       ``minimum`` : minimum value of the variable

       ``maximum`` : maximum value of the variable

       ``mode`` : mode value of the variable


   **Returns**:

       ``Pbox``



.. py:function:: min_max_median(minimum: Union[pyuncertainnumber.pba.interval.Interval, float, int], maximum: Union[pyuncertainnumber.pba.interval.Interval, float, int], median: Union[pyuncertainnumber.pba.interval.Interval, float, int], steps: int = Params.steps) -> pyuncertainnumber.pba.pbox_base.Pbox

   Generates a distribution-free p-box based upon the minimum, maximum and median of the variable

   **Parameters**:

       ``minimum`` : minimum value of the variable

       ``maximum`` : maximum value of the variable

       ``median`` : median value of the variable


   **Returns**:

       ``Pbox``



.. py:function:: min_max_median_is_mode(minimum: Union[pyuncertainnumber.pba.interval.Interval, float, int], maximum: Union[pyuncertainnumber.pba.interval.Interval, float, int], m: Union[pyuncertainnumber.pba.interval.Interval, float, int], steps: int = Params.steps) -> pyuncertainnumber.pba.pbox_base.Pbox

   Generates a distribution-free p-box based upon the minimum, maximum and median/mode of the variable when median = mode.

   **Parameters**:

       ``minimum`` : minimum value of the variable

       ``maximum`` : maximum value of the variable

       ``m`` : m = median = mode value of the variable


   **Returns**:

       ``Pbox``



.. py:function:: mean_std(mean: Union[pyuncertainnumber.pba.interval.Interval, float, int], std: Union[pyuncertainnumber.pba.interval.Interval, float, int], steps=Params.steps) -> pyuncertainnumber.pba.pbox_base.Pbox

   Generates a distribution-free p-box based upon the mean and standard deviation of the variable

   **Parameters**:

       ``mean`` : mean of the variable

       ``std`` : standard deviation of the variable


   **Returns**:

       ``Pbox``



.. py:function:: mean_var(mean: Union[pyuncertainnumber.pba.interval.Interval, float, int], var: Union[pyuncertainnumber.pba.interval.Interval, float, int], steps=Params.steps) -> pyuncertainnumber.pba.pbox_base.Pbox

   Generates a distribution-free p-box based upon the mean and variance of the variable

   Equivalent to `mean_std(mean,np.sqrt(var))`

   **Parameters**:

       ``mean`` : mean of the variable

       ``var`` : variance of the variable


   **Returns**:

       ``Pbox``



.. py:function:: pos_mean_std(mean: Union[pyuncertainnumber.pba.interval.Interval, float, int], std: Union[pyuncertainnumber.pba.interval.Interval, float, int], steps=Params.steps) -> pyuncertainnumber.pba.pbox_base.Pbox

   Generates a positive distribution-free p-box based upon the mean and standard deviation of the variable

   **Parameters**:

       ``mean`` : mean of the variable

       ``std`` : standard deviation of the variable


   **Returns**:

       ``Pbox``



.. py:function:: symmetric_mean_std(mean: Union[pyuncertainnumber.pba.interval.Interval, float, int], std: Union[pyuncertainnumber.pba.interval.Interval, float, int], steps: int = Params.steps) -> pyuncertainnumber.pba.pbox_base.Pbox

   Generates a symmetrix distribution-free p-box based upon the mean and standard deviation of the variable

   **Parameters**:

   ``mean`` :  mean value of the variable
   ``std`` : standard deviation of the variable

   **Returns**

       ``Pbox``



.. py:function:: from_percentiles(percentiles: dict, steps: int = Params.steps) -> pyuncertainnumber.pba.pbox_base.Pbox

   Generates a distribution-free p-box based upon percentiles of the variable

   **Parameters**

       ``percentiles`` : dictionary of percentiles and their values (e.g. {0: 0, 0.1: 1, 0.5: 2, 0.9: nInterval(3,4), 1:5})

       ``steps`` : number of steps to use in the p-box

   .. important::

       The percentiles dictionary is of the form {percentile: value}. Where value can either be a number or an nInterval. If value is a number, the percentile is assumed to be a point percentile. If value is an nInterval, the percentile is assumed to be an interval percentile.

   .. warning::

       If no keys for 0 and 1 are given, ``-np.inf`` and ``np.inf`` are used respectively. This will result in a p-box that is not bounded and raise a warning.

       If the percentiles are not increasing, the percentiles will be intersected. This may not be desired behaviour.

   .. error::

       ``ValueError``: If any of the percentiles are not between 0 and 1.

   **Returns**

       ``Pbox``


   **Example**:

   .. code-block:: python

       pba.from_percentiles(
           {0: 0,
           0.25: 0.5,
           0.5: pba.I(1,2),
           0.75: pba.I(1.5,2.5),
           1: 3}
       ).show()

   .. image:: https://github.com/Institute-for-Risk-and-Uncertainty/pba-for-python/blob/master/docs/images/from_percentiles.png?raw=true
       :scale: 35 %
       :align: center
       :alt: Pbox generated from percentiles



.. py:function:: KS_bounds(s, alpha: float, display=True) -> Tuple[pyuncertainnumber.pba.utils.CDF_bundle, pyuncertainnumber.pba.utils.CDF_bundle]

   construct free pbox from sample data by Kolmogorov-Smirnoff confidence bounds

   :param - s: sample data, precise and imprecise
   :type - s: array-like
   :param - dn: KS critical value at significance level lpha and sample size N;
   :type - dn: scalar


.. py:function:: fit(method: str, family: str, data: numpy.ndarray)

   top-level fit from data

   :param - method: method of fitting, e.g., {'mle' or 'mom'} 'entropy', 'pert', 'fermi', 'bayesian'
   :type - method: str
   :param - family: distribution family to be fitted
   :type - family: str
   :param - data: data to be fitted
   :type - data: np.ndarray

   .. note:: - supported family list can be found in xx.

   :returns:

             - the return from the constructors below are `scipy.stats.dist` objects or `UN` objects depending on the decorator

   .. rubric:: Example

   >>> pun.fit('mle', 'norm', np.random.normal(0, 1, 100))


.. py:function:: stochastic_mixture(l_uns, weights=None, display=False, **kwargs)

   it could work for either Pbox, distribution, DS structure or Intervals

   :param - l_un: list of uncertain numbers
   :type - l_un: list
   :param - weights: list of weights
   :type - weights: list
   :param - display: boolean for plotting
   :type - display: Boolean

   # TODO mix types later
   .. note:: - currently only accepts same type objects


.. py:function:: envelope(*args: pyuncertainnumber.pba.interval.nInterval | pyuncertainnumber.pba.pbox_base.Pbox | float) -> pyuncertainnumber.pba.interval.nInterval | pyuncertainnumber.pba.pbox_base.Pbox

   .. _core.envelope:

   Allows the envelope to be calculated for intervals and p-boxes.

   The envelope is the smallest interval/pbox that contains all values within the arguments.

   **Parameters**:
       ``*args``: The arguments for which the envelope needs to be calculated. The arguments can be intervals, p-boxes, or floats.

   **Returns**:
       ``Pbox|Interval``: The envelope of the given arguments, which can be an interval or a p-box.

   .. error::

       ``ValueError``: If less than two arguments are given.

       ``TypeError``: If none of the arguments are intervals or p-boxes.



.. py:function:: imposition(*args: pyuncertainnumber.pba.pbox_base.Pbox | pyuncertainnumber.pba.interval.nInterval | float | int)

   Returns the imposition/intersection of the p-boxes in *args

   :param - UN objects to be mixed:

   :returns:

             - Pbox

   .. note:: - #TODO verfication needed for the base function `p1.imp(p2)`


.. py:function:: stacking(vec_interval: pyuncertainnumber.pba.interval.nInterval | pyuncertainnumber.pba.intervals.Interval, weights, display=False, return_type='pbox')

   stochastic mixture operation of Intervals with probability masses

   :param - l_un: list of uncertain numbers
   :type - l_un: list
   :param - weights: list of weights
   :type - weights: list
   :param - display: boolean for plotting
   :type - display: Boolean
   :param - return_type: {'pbox' or 'ds' or 'bounds'}
   :type - return_type: str

   :returns:

             - the left and right bound F in `cdf_bundlebounds` by default
             but can choose to return a p-box

   .. note::

      - together the interval and masses, it can be deemed that all the inputs
      required is jointly a DS structure


.. py:function:: hedge_interpret(hedge: str, return_type='interval') -> pyuncertainnumber.pba.interval.Interval | pyuncertainnumber.pba.pbox_base.Pbox

   interpret linguistic hedge words into UncertainNumber objects

   :param hedge: the hedge numerical expression to be interpreted
   :type hedge: str
   :param return_type: the type of object to be returned, either 'interval' or 'pbox'
   :type return_type: str

   .. note:: - the return can either be an interval or a pbox object

   .. rubric:: Example

   >>> hedge_interpret("about 200", return_type="pbox")


.. py:function:: infer_cbox(family: str, data, **args) -> pyuncertainnumber.pba.cbox_Leslie.Cbox

   top-level call signature to infer a c-box given data and family, plus rarely additional kwargs

   .. rubric:: Notes

   - data (list): a list of data samples, e.g. [2]
   - additina kwargs such as N for binomial family

   .. rubric:: Example

   >>> infer_cbox('binomial', data=[2], N=10)


.. py:function:: infer_predictive_distribution(family: str, data, **args)

   top-level call for the next value predictive distribution


.. py:class:: dempstershafer_element

   Bases: :py:obj:`tuple`


   .. py:attribute:: interval


   .. py:attribute:: mass


.. py:class:: DempsterShafer(intervals, masses: list[float])

   Class for Dempester-Shafer structures.

   :param - the `intervals` argument accepts wildcard vector intervals {list of list pairs:
   :param Interval:
   :param pairs of nInterval};:
   :param - masses: probability masses
   :type - masses: list


   .. py:attribute:: _intrep


   .. py:attribute:: _intervals


   .. py:attribute:: _masses


   .. py:method:: _create_DSstructure()


   .. py:property:: structure


   .. py:property:: intervals


   .. py:property:: masses


   .. py:method:: disassemble()


   .. py:method:: display(style='box', **kwargs)


   .. py:method:: to_pbox()


   .. py:method:: from_dsElements(*ds_elements: dempstershafer_element)
      :classmethod:


      Create a Dempster-Shafer structure from a list of Dempster-Shafer elements.



